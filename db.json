{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/apollo/source/favicon.png","path":"favicon.png","modified":0,"renderable":1},{"_id":"themes/apollo/source/logo.svg","path":"logo.svg","modified":0,"renderable":1},{"_id":"themes/apollo/source/css/apollo.css","path":"css/apollo.css","modified":0,"renderable":1},{"_id":"themes/apollo/source/font/sourcesanspro.woff","path":"font/sourcesanspro.woff","modified":0,"renderable":1},{"_id":"themes/apollo/source/font/sourcesanspro.woff2","path":"font/sourcesanspro.woff2","modified":0,"renderable":1},{"_id":"themes/apollo/source/scss/apollo.scss","path":"scss/apollo.scss","modified":0,"renderable":1}],"Cache":[{"_id":"themes/apollo/.gitignore","hash":"a006beea0877a0aa3610ee00e73f62cb1d45125b","modified":1482157677000},{"_id":"themes/apollo/LICENSE","hash":"6e31ac9076bfc8f09ae47977419eee4edfb63e5b","modified":1482157677000},{"_id":"themes/apollo/logo.svg","hash":"f3ac16f307650171a7c85f587345216b8aeca469","modified":1482157677000},{"_id":"themes/apollo/_config.yml","hash":"6635840dc4c4e9e6baab6595e2c90acca2c8c72a","modified":1482157677000},{"_id":"themes/apollo/gulpfile.js","hash":"6f1cb8973e0cd8d696fb3412e9696bc77396935b","modified":1482157677000},{"_id":"themes/apollo/package.json","hash":"eb1e76ec0b7ed6c6c7b2bd32b4f1e1bbe15800ca","modified":1482157677000},{"_id":"source/_posts/javascript-102.md","hash":"ffe96608ec31012dee380d2cf0bc8f01d12dfd90","modified":1482170971000},{"_id":"themes/apollo/layout/archive.pug","hash":"62797414355bf4474092bc3a32726c8340820ffb","modified":1482157677000},{"_id":"themes/apollo/layout/index.pug","hash":"55f2f1b4b5364a0e09cb18e1112664c6415fb881","modified":1482157677000},{"_id":"themes/apollo/source/favicon.png","hash":"4742cfae8e75dc4cc690490970e9ae420e5b2063","modified":1482157677000},{"_id":"themes/apollo/source/logo.svg","hash":"f3ac16f307650171a7c85f587345216b8aeca469","modified":1482157677000},{"_id":"themes/apollo/languages/en.yml","hash":"40292f2a48e4e6361132033a47c516cb33127b6c","modified":1482157677000},{"_id":"themes/apollo/layout/post.pug","hash":"245c26244c075c3632d1545c3b228ee9d112f15d","modified":1482157677000},{"_id":"themes/apollo/layout/partial/head.pug","hash":"a4c7639a4ef887f4a9317bde78f929137d7518d6","modified":1482157677000},{"_id":"themes/apollo/layout/mixins/post.pug","hash":"4166384f79ccc25242d87018f28f0fc2cfad2863","modified":1482195143000},{"_id":"themes/apollo/layout/partial/copyright.pug","hash":"c10d7640e1436c67a76dfc94f36f9675aa1308af","modified":1482157677000},{"_id":"themes/apollo/layout/partial/comment.pug","hash":"ff0a2c269c2434da2ac5529872f1d6184a71f96d","modified":1482157677000},{"_id":"themes/apollo/layout/partial/nav.pug","hash":"f4842d9d3d763fbb823d112a6f49f24cc42a0ad4","modified":1482157677000},{"_id":"themes/apollo/layout/partial/layout.pug","hash":"529c2ec06cfbc3d5b6d66dd320db50dfab5577a6","modified":1482157677000},{"_id":"themes/apollo/layout/partial/scripts.pug","hash":"6bff591ae3d1ff6750f239c4c933ad61f009f36a","modified":1482157677000},{"_id":"themes/apollo/source/css/apollo.css","hash":"02586c319f98da4c57360abb66c2db45e5b4d26e","modified":1482157677000},{"_id":"themes/apollo/source/font/sourcesanspro.woff","hash":"a6722c9b6439b7a020a9be3d3178970757a9265c","modified":1482157677000},{"_id":"themes/apollo/source/font/sourcesanspro.woff2","hash":"da65f527a8da65d5eb6721626d28cfdb46ab104a","modified":1482157677000},{"_id":"themes/apollo/source/scss/apollo.scss","hash":"e0092f469264b55b25e0d441274f1c812147e7d1","modified":1482157677000},{"_id":"themes/apollo/layout/mixins/paginator.pug","hash":"f4ee2fb61a32e199b48cf93771749edc8a007391","modified":1482157677000},{"_id":"themes/apollo/source/scss/_partial/archive-post-list.scss","hash":"77c9a321e29d2a38cfd57151fdf921129cfde7a8","modified":1482157677000},{"_id":"themes/apollo/source/scss/_partial/base.scss","hash":"9dcf126478c8d4b52763b2080d3df9e177a4730b","modified":1482157677000},{"_id":"themes/apollo/source/scss/_partial/copyright.scss","hash":"1309667e3000037170cfbb5b8c9c65f4ffcf6814","modified":1482157677000},{"_id":"themes/apollo/source/scss/_partial/footer.scss","hash":"92196909252ae7afd90526c94ae3e6d49919b9d5","modified":1482157677000},{"_id":"themes/apollo/source/scss/_partial/header.scss","hash":"dcec37396742df4c47e099600522d138cc008d28","modified":1482157677000},{"_id":"themes/apollo/source/scss/_partial/home-post-list.scss","hash":"056e3dc4851ae148407afa2ad0683d0376bfe1d3","modified":1482157677000},{"_id":"themes/apollo/source/scss/_partial/mq.scss","hash":"fc5dda52cfbb10e27e2471e03f4606fb3d588225","modified":1482157677000},{"_id":"themes/apollo/source/scss/_partial/normalize.scss","hash":"fd0b27bed6f103ea95b08f698ea663ff576dbcf1","modified":1482157677000},{"_id":"themes/apollo/source/scss/_partial/post.scss","hash":"199f9876671178bc6e01932b5d584fcb69e201ad","modified":1482157677000},{"_id":"source/_posts/javascript-102/indentation-hell.jpg","hash":"766eef0e1e855c39734922a4c70dce969710dc60","modified":1482168545000},{"_id":"source/_posts/javascript-102/loop-patterns.png","hash":"12839e10f833dacf5a2a2be761dc129759bf5b0a","modified":1482166154000},{"_id":"public/CNAME","hash":"5e86ada9a7da1206d4e6bdf696ea0d46cf4d6d85","modified":1482171159997},{"_id":"public/sitemap.xml","hash":"6493b34e402a14efd8e5068c5f43198537610526","modified":1482171160003},{"_id":"public/atom.xml","hash":"83c2f10da95ccc94d6a6e33ec101e591c3464054","modified":1482171160002},{"_id":"public/categories/JavaScript/index.html","hash":"08acfc98bfb94ce6453f9ac0d7fffcff93f8c65f","modified":1482171160006},{"_id":"public/archives/index.html","hash":"ce39795d60bd931790f9cabbd9d07d7a8b0f22f8","modified":1482171160006},{"_id":"public/index.html","hash":"65f87a546aae36ea80c8e80f170e3e2c3e96c238","modified":1482171160007},{"_id":"public/tags/JavaScript/index.html","hash":"08acfc98bfb94ce6453f9ac0d7fffcff93f8c65f","modified":1482171160007},{"_id":"public/tags/Lodash/index.html","hash":"08acfc98bfb94ce6453f9ac0d7fffcff93f8c65f","modified":1482171160008},{"_id":"public/tags/Code-Quality/index.html","hash":"08acfc98bfb94ce6453f9ac0d7fffcff93f8c65f","modified":1482171160008},{"_id":"public/2016/12/19/javascript-102/index.html","hash":"ce0ab7a0bfa6e43430eed6e75617224ab81043ae","modified":1482171160008},{"_id":"public/favicon.png","hash":"4742cfae8e75dc4cc690490970e9ae420e5b2063","modified":1482171037829},{"_id":"public/logo.svg","hash":"f3ac16f307650171a7c85f587345216b8aeca469","modified":1482171037829},{"_id":"public/font/sourcesanspro.woff","hash":"a6722c9b6439b7a020a9be3d3178970757a9265c","modified":1482171037830},{"_id":"public/font/sourcesanspro.woff2","hash":"da65f527a8da65d5eb6721626d28cfdb46ab104a","modified":1482171037830},{"_id":"public/scss/apollo.scss","hash":"e0092f469264b55b25e0d441274f1c812147e7d1","modified":1482171037830},{"_id":"public/2016/12/19/javascript-102/indentation-hell.jpg","hash":"766eef0e1e855c39734922a4c70dce969710dc60","modified":1482171037830},{"_id":"public/css/apollo.css","hash":"02586c319f98da4c57360abb66c2db45e5b4d26e","modified":1482171037836},{"_id":"public/2016/12/19/javascript-102/loop-patterns.png","hash":"12839e10f833dacf5a2a2be761dc129759bf5b0a","modified":1482171037836}],"Category":[{"name":"JavaScript","_id":"ciwwar0lu0001gqgf214kbo9o"}],"Data":[],"Page":[],"Post":[{"title":"JavaScript 102","author":"Hans Lee","date":"2016-12-19T08:45:00.000Z","_content":"\nJavaScript is essential to companies using `Node.js`. It's THE language of year 2016. However, it is also a fragile language could be easily abused.\n\n<!-- more -->\n## Road toward clean code (less bug)\n\nIn this article, I am going to demonstrate some best practices in JavaScript with examples.\n\n## `sum` function\nTo begin with, we are required to write a simple sum function. Here is the requirement:\n\n1. the function accepts **1** argument - an array of numbers\n2. the function should return the sum of all the numbers inside the array\n\n### for loop (not recommended)\n\n``` javascript\n// array = [1,2,3,4]\nfunction sum(array) {\n  let result = 0;\n  for (var i = 0; i < array.length; i++) {\n    result += array[i];\n  }\n  return result;\n}\n```\n\nThe first approach is intuitive: use traditional `for` loop. There is nothing wrong about it, but as a js developer, we could do better.\n\n### for ... in loop (**DEPRECATED**, DO NOT USE)\n\nAnd here is the famous `foo ... in` loop.\n\nAs you can see, the obvious drawback of `for ... in` loop is that it could iterate over all of the keys and all the keys on it's prototype chain inside an object (array is also an object in js), therefore we have this `hasOwnProperty` check.\n\nan astonishing fact is that a lot of programmers from other languages really love this approach... However, the cold fact is due to the cumbersome `hasOwnProperty` check, `for ... in` loop is seldom used in most of the `Node.js` project, and even considered bad practice when iterate over a collection.\n\nHere is the reason:\n\n>  The for-in statement by itself is not a \"bad practice\", however it can be mis-used, for example, to iterate over arrays or array-like objects.\n\n> The purpose of the for-in statement is to enumerate over object properties. This statement will go up in the prototype chain, also enumerating over inherited properties, a thing that sometimes is not desired.\n\n> Also, the order of iteration is not guaranteed by the spec., meaning that if you want to \"iterate\" an array object, with this statement you cannot be sure that the properties (array indexes) will be visited in the numeric order.\n\n``` javascript\n// array = [1,2,3,4]\nfunction sum(array) {\n  let result = 0;\n  for (let index in array) {\n    if (array.hasOwnProperty(index)) {\n      result += array[index];\n    }\n  }\n  return result;\n}\n```\n\nIf one should iterate over every property in an `object` (`{}`) rather than `array` (`[]`), consider use those methods:\n\n``` javascript\nObject.keys           <-> _.keys\nObject.values  (es7)  <-> _.values\nObject.entries (es7)  <-> _.pairs\n```\n\nThose methods are not following the prototype chain to do an exhaustive search so they may even have better performance compared to the `for ... in` loop.\n\n### for ... of loop (es6) (Okay.. not the best)\n\n``` javascript\n// array = [1,2,3,4]\nfunction sum(array) {\n  let result = 0;\n  for (let number of array) {\n    result += number;\n  }\n  return result;\n}\n```\n\nthis is a more recommended way to iterate a collection (or iterable to be precise).\n\n`for ... of` will not follow the prototype chain as well, because it can only be used on `iterable object`. And `Array` in es6 is implemented as an iterable. [iterable-mdn](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators)\n\n### Array.prototype.forEach (Okay, not the best)\n\n``` javascript\n// array = [1,2,3,4]\nfunction sum(array) {\n  let result = 0;\n  array.forEach(number => result += number);\n  return result;\n}\n```\n\nNothing wrong about it, but we still need a `result` tmp var.\n\n\n### Array.prototype.reduce (better)\n\n``` javascript\n// array = [1,2,3,4]\nfunction sum(array) {\n  return array.reduce((pre, cur) => {\n    return pre + cur;\n  });\n}\n```\n\nthis it the killer function of javascript, reduce function simply turns a `collection` in to a single value.\n\n<div class=\"tip\">\nRemember, you MUST return the accumulated result in the reducer function\n</div>\n\nWe finally get rid of the annoying tmp var `result`! Yeal~\n\n\n### \\_.sum (best)\n\n``` javascript\n// array = [1,2,3,4]\nfunction sum(array) {\n  return _.sum(array);\n}\n```\n\nThe real killer in JavaScript is the `lodash` library. It has became the de-factor JavaScript utility library. So Whenever you starts to write a function, the first thing to come up is always:\n\ncan i achieve it in lodash?\n\ncan i achieve it in lodash?\n\ncan i achieve it in lodash?\n\n(have to repeat 3 times to emphersize important things)\n\n<div class=\"tip\">\nAlways exploring lodash for data transformation tasks\n</div>\n\n## `clean` function\n\nconsider the `clean` function here:\n\n``` javascript\n// ['tag1', 'tag2', 'tag1  '] -> ['tag1', 'tag2']\nfunction clean(tags) {\n  let dedupe = {};\n  for (let i = 0; i < tags.length; i++){\n    tags[i] = tags[i].trim();\n    const aTag = tags[i];\n\n    if(dedupe[aTag]) {\n      tags.splice(i, 1);\n      i--;\n    } else {\n      dedupe[aTag] = true;\n    }\n  }\n  return tags;\n}\n```\n\nit takes some time to brain-parse this function, it seems to work but it has a potential bug: it changes the reference of the argument passed in.\n\n### impurity\n\n``` diff\n// ['tag1', 'tag2', 'tag1  '] -> ['tag1', 'tag2']\nfunction clean(tags) {\n  let dedupe = {};\n  for (let i = 0; i < tags.length; i++){\n-    tags[i] = tags[i].trim(); // mutates the tags\n    const aTag = tags[i];\n\n    if(dedupe[aTag]) {\n-      tags.splice(i, 1); // mutates the tags\n      i--;\n    } else {\n      dedupe[aTag] = true;\n    }\n  }\n  return tags;\n}\n```\n\nwithout mentioning the mysterious `splice` method with a dynamic `i` variable you need to brain-parse, the highlighted 2 lines are directly mutating the argument.\n\nImagine the `tags` argument passed in could be used in somewhere else, then this function has a side effect that is really hard to predict and could lead to a bug that is extremely hard to trace.\n\nThis is called `side effect` in functional programming world. and the `clean` function above is defined as `impure`\n\n### pure function\nSo we could come up with a better solution:\n\n``` diff\n// ['tag1', 'tag2', 'tag1  '] -> ['tag1', 'tag2']\nfunction clean(tags) {\n  let dedupe = {};\n+ let result = [];\n  for (let i = 0; i < tags.length; i++){\n-   tags[i] = tags[i].trim(); // mutates the tags\n+   const aTag = tags[i].trim();\n\n    if(dedupe[aTag]) {\n-     tags.splice(i, 1); // mutates the tags\n-     i--;\n+     result.push(aTag);\n    } else {\n      dedupe[aTag] = true;\n    }\n  }\n  return tags;\n}\n```\n\nwith this implementation, at least we have get rid of the side effects and eliminated a potential caused by direct data mutation, but we could still do better:\n\n### Concatenated loops\n\n{% asset_img \"loop-patterns.png\" \"Loop patterns\" %}\n\nAs illustrated in the image above, generally a good practice is try to wring `Concatenated loop`.\n\nTo achieve this goal, we could follow a simple rule:\n\n> Inside loop, try to do only 1 thing\n\ntry to apply that to the `clean` function, we could get\n\n``` javascript\n// ['tag1', 'tag2', 'tag1'] -> ['tag1', 'tag2']\nfunction clean(tags) {\n  let dedupe = {};\n  let result = [];\n\n  for (let i = 0; i < tags.length; i++) {\n    dedupe[tags[i].trim()] = true;\n  }\n\n  for (let i = 0; i < tags.length; i++) {\n    if (dedupe[tags[i].trim()]) {\n      result.push(tags[i])\n    }\n  }\n\n  return result;\n}\n```\n\nHere inside those 2 loops, we could easily figure out what they are doing respectively.\n\n\n### Lazy evaluation\n\nHowever, some people may ask: this is a `O(2n)` compared to the previous `O(n)` function.\n\nHere will introduce the killer feature of `lodash` - chainable api\n\nit is basically implemented using `_.chain(collection)` method, or `_(collection)` as a shorthand, and could be optimized easily\n\n``` javascript\nconst result = _(source).map(func1).map(func2).map(func3).value();\n```\n\nis transformed to something like following in normal mode.\n\n``` javascript\nlet result = [], temp1 = [], temp2 = [], temp3 = [];\n\nfor (var i = 0; i < source.length; i++) {\n temp1[i] = func1(source[i]);\n}\n\nfor (i = 0; i < source.length; i++) {\n temp2[i] = func2(temp1[i]);\n}\n\nfor (i = 0; i < source.length; i++) {\n temp3[i] = func3(temp2[i]);\n}\n\nresult = temp3;\n```\n\nBut in the lazy mode (could be accomplished with `lazy.js`):\n\n``` javascript\nlet result = [];\nfor (var i = 0; i < source.length; i++) {\n  result[i] = func3(func2(func1(source[i])));\n}\n```\n\nas you could see, `O(kn)` algorithm has been optimized to `O(n)`. With pure `for` loop, this optimization is not easy to be achived, but with `lodash` and a sequence of function transformation, this could be easily achieved.\n\n### Lodash Chainable API: rewrite `clean` function\n\n``` javascript\n// ['tag1', 'tag2  ', 'tag1 '] -> ['tag1', 'tag2']\nfunction clean(tags) {\n  return _(tags)\n    .map(_.trim)\n    .uniq()\n    .value();\n}\n```\n\nthis is so much cleaner than the first version of above!\n\nread the documentation on [lodash chain](https://lodash.com/docs/4.17.2#chain) for more black magic\n\n## `mergeAndOverwrite` function\n\nconsider the function below:\n\n``` javascript\nfunction mergeAndOverwrite(target, source) {\n  target = _.merge(_.cloneDeep(target), source.merge);\n\n  for (let config_key in source.overwrite) {\n    if (source.overwrite.hasOwnProperty(config_key)) {\n      target[config_key] = source.overwrite[config_key];\n    }\n  }\n\n  return target;\n}\n```\n\nthere are 2 gotchas:\n1. 1st parameter in `_.merge` could be an empty object, and `_.merge` is a recursive deep operation already, so `_.cloneDeep` is somewhat a cumbersome call.\n2. the for ... in loop could be entirely replaced by `Object.assign`\n\n\n### \\_.merge vs Object.assign\n\nThose 2 functions are similar but do things in totally different ways:\n\n1. \\.merge is a recursive call, so it traverses **every** property all object and merge them\n2. Object.assign only overwrite the 1st layer of right hand-side to left hands-side\n\n``` javascript\n// => { \"a\": { \"a\": \"a\",\"b\":\"bb\" }}\n_.merge({}, {a:{a:'a'}}, {a:{b:'bb'}})\n// => { \"a\": { \"b\": \"bb\" }}\nObject.assign({}, {a:{a:'a'}}, {a:{b:'bb'}})\n\n// => { \"a\": [ \"bb\" ] }\n_.merge({}, {a:['a']}, {a:['bb']})\n// => { \"a\": [ \"bb\" ] }\nObject.assign({}, {a:['a']}, {a:['bb']})\n```\n\n### rewrite the `mergeAndOverwrite` function\n\n``` javascript\nfunction mergeAndOverwrite(target, source) {\n  const merged = _.merge(\n    {},\n    target,\n    source.merge\n  );\n  return Object.assign(\n    merged,\n    source.overwrite\n  );\n}\n```\n\n<div class=\"tip\">\nRead through Lodash doc before using \\_.cloneDeep\n</div>\n\n## Final challenge: indentation hell\n\nTo wrap up, consider the following function\n\n``` javascript\nfunction filterAck(acl_hash) {\n  // 0\n  let filtered_api_acl = {};\n  for (let api_version in acl_hash) {\n    // 1\n    if (acl_hash.hasOwnProperty(api_version)) {\n      // 2\n      if (config.api_key.default_user_api_acl[api_version]) {\n        // 3\n        filtered_api_acl[api_version] = [];\n        if (_.isArray(acl_hash[api_version])) {\n          // 4\n          for (let i = 0; i < acl_hash[api_version].length; i++) {\n            // 5\n            if (config.api_key.default_user_api_acl[api_version].indexOf(acl_hash[api_version][i]) !== -1) {\n              // 6\n              filtered_api_acl[api_version].push(acl_hash[api_version][i]);\n            }\n          }\n        }\n      }\n    }\n  }\n  return filtered_api_acl;\n}\n```\n\n<div class=\"tip\">\nWe human beings are not good at reading deeply nested indentation hells: Research shows we only have 7 buffers for short term memory... So code like below will literally burn our brain out.\n</div>\n\n{% asset_img \"indentation-hell.jpg\" \"indentation hell\" %}\n\nWhenever writing code, try your best to keep the indentation level <= 3 is generally a good practice, **this could vastly improve maintainability of code.**\n\n### 1. use `Object.keys` to iterate an object\n\nindentation level `-1`, current `5`\n\n``` diff\nfunction filterAck(acl_hash) {\n  let filtered_api_acl = {};\n- for (let api_version in acl_hash) {\n-   if (acl_hash.hasOwnProperty(api_version)) {\n+ Object.keys(acl_hash).forEach(api_version => {\n-     if (config.api_key.default_user_api_acl[api_version]) {\n+   if (config.api_key.default_user_api_acl[api_version]) {\n-       filtered_api_acl[api_version] = [];\n+     filtered_api_acl[api_version] = [];\n-       if (_.isArray(acl_hash[api_version])) {\n+     if (_.isArray(acl_hash[api_version])) {\n-         for (let i = 0; i < acl_hash[api_version].length; i++) {\n+       for (let i = 0; i < acl_hash[api_version].length; i++) {\n-           if (config.api_key.default_user_api_acl[api_version].indexOf(acl_hash[api_version][i]) !== -1) {\n+         if (config.api_key.default_user_api_acl[api_version].indexOf(acl_hash[api_version][i]) !== -1) {\n-             filtered_api_acl[api_version].push(acl_hash[api_version][i]);\n            // 5\n+           filtered_api_acl[api_version].push(acl_hash[api_version][i]);\n-           }\n+         }\n-         }\n+       }\n-       }\n+     }\n-     }\n+   }\n- }\n+ });\n  return filtered_api_acl;\n}\n```\n\n### 2. use `_.intersction` to simplify replace the inner loop\n\nindentation level `-2`, current: `3`\n\n``` diff\nfunction filterAcl(acl_hash) {\n  let filtered_api_acl = {};\n  Object.keys(acl_hash).forEach(api_version => {\n    if (config.api_key.default_user_api_acl[api_version]) {\n+     filtered_api_acl[api_version] = [];\n      if (_.isArray(acl_hash[api_version])) {\n-       for (let i = 0; i < acl_hash[api_version].length; i++) {\n-         if (config.api_key.default_user_api_acl[api_version].indexOf(acl_hash[api_version][i]) !== -1) {\n-           filtered_api_acl[api_version].push(acl_hash[api_version][i]);\n-         }\n-       }\n        // 3\n+       filtered_api_acl[api_version] = _.intersction(\n+         config.api_key.default_user_api_acl[api_version],\n+         acl_hash\n+       )\n      }\n    }\n  })\n  return filtered_api_acl;\n}\n```\n\n### 3. return in advance to reduce indentation level\n\nindentation level `-1`, current `2`\n\n``` javascript\nfunction filterAcl(acl_hash) {\n  let filtered_api_acl = {};\n  Object.keys(acl_hash).forEach(api_version => {\n    if (!config.api_key.default_user_api_acl[api_version]) {\n      // 2\n      return;\n    }\n\n    if (!_.isArray(acl_hash[api_version])) {\n      return;\n    }\n\n    filtered_api_acl[api_version] = [];\n\n    filtered_api_acl[api_version] = _.intersection(\n      config.api_key.default_user_api_acl[api_version],\n      acl_hash[api_version]\n    );\n  });\n\n  return filtered_api_acl;\n}\n```\n\n### 4. final step: use lodash to wrap everything\n\nindentation level `-2`, current `0`\n\n``` javascript\nfunction filterAcl(acl_hash) {\n  return _\n    .chain(Object.keys(acl_hash))\n    .filter(api_version => config.api_key.default_user_api_acl[api_version])\n    .filter(api_version => Array.isArray(acl_hash[api_version]))\n    .map(api_version => ([\n      api_version,\n      _.intersection(\n        config.api_key.default_user_api_acl,\n        acl_hash[api_version]\n      )\n    ]))\n    .fromPairs()\n    .value();\n}\n```\n\n## Final Words\n\n<div class=\"tip\">\nUse Lodash!\n</div>\n\n#### references:\n\n* [lodash-doc](https://lodash.com/docs/4.17.2)\n* [lazy-js-intro](http://philosopherdeveloper.com/posts/introducing-lazy-js.html)\n* [for-in-stackoverflow](http://stackoverflow.com/questions/500504/why-is-using-for-in-with-array-iteration-a-bad-idea)\n* [simple-rules-for-simple-code](https://laracasts.com/series/simple-rules-for-simpler-code)\n","source":"_posts/javascript-102.md","raw":"---\ntitle: JavaScript 102\nauthor: Hans Lee\ndate: 2016-12-19 16:45\ncategories:\n  - JavaScript\ntags:\n  - JavaScript\n  - Lodash\n  - Code Quality\n---\n\nJavaScript is essential to companies using `Node.js`. It's THE language of year 2016. However, it is also a fragile language could be easily abused.\n\n<!-- more -->\n## Road toward clean code (less bug)\n\nIn this article, I am going to demonstrate some best practices in JavaScript with examples.\n\n## `sum` function\nTo begin with, we are required to write a simple sum function. Here is the requirement:\n\n1. the function accepts **1** argument - an array of numbers\n2. the function should return the sum of all the numbers inside the array\n\n### for loop (not recommended)\n\n``` javascript\n// array = [1,2,3,4]\nfunction sum(array) {\n  let result = 0;\n  for (var i = 0; i < array.length; i++) {\n    result += array[i];\n  }\n  return result;\n}\n```\n\nThe first approach is intuitive: use traditional `for` loop. There is nothing wrong about it, but as a js developer, we could do better.\n\n### for ... in loop (**DEPRECATED**, DO NOT USE)\n\nAnd here is the famous `foo ... in` loop.\n\nAs you can see, the obvious drawback of `for ... in` loop is that it could iterate over all of the keys and all the keys on it's prototype chain inside an object (array is also an object in js), therefore we have this `hasOwnProperty` check.\n\nan astonishing fact is that a lot of programmers from other languages really love this approach... However, the cold fact is due to the cumbersome `hasOwnProperty` check, `for ... in` loop is seldom used in most of the `Node.js` project, and even considered bad practice when iterate over a collection.\n\nHere is the reason:\n\n>  The for-in statement by itself is not a \"bad practice\", however it can be mis-used, for example, to iterate over arrays or array-like objects.\n\n> The purpose of the for-in statement is to enumerate over object properties. This statement will go up in the prototype chain, also enumerating over inherited properties, a thing that sometimes is not desired.\n\n> Also, the order of iteration is not guaranteed by the spec., meaning that if you want to \"iterate\" an array object, with this statement you cannot be sure that the properties (array indexes) will be visited in the numeric order.\n\n``` javascript\n// array = [1,2,3,4]\nfunction sum(array) {\n  let result = 0;\n  for (let index in array) {\n    if (array.hasOwnProperty(index)) {\n      result += array[index];\n    }\n  }\n  return result;\n}\n```\n\nIf one should iterate over every property in an `object` (`{}`) rather than `array` (`[]`), consider use those methods:\n\n``` javascript\nObject.keys           <-> _.keys\nObject.values  (es7)  <-> _.values\nObject.entries (es7)  <-> _.pairs\n```\n\nThose methods are not following the prototype chain to do an exhaustive search so they may even have better performance compared to the `for ... in` loop.\n\n### for ... of loop (es6) (Okay.. not the best)\n\n``` javascript\n// array = [1,2,3,4]\nfunction sum(array) {\n  let result = 0;\n  for (let number of array) {\n    result += number;\n  }\n  return result;\n}\n```\n\nthis is a more recommended way to iterate a collection (or iterable to be precise).\n\n`for ... of` will not follow the prototype chain as well, because it can only be used on `iterable object`. And `Array` in es6 is implemented as an iterable. [iterable-mdn](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators)\n\n### Array.prototype.forEach (Okay, not the best)\n\n``` javascript\n// array = [1,2,3,4]\nfunction sum(array) {\n  let result = 0;\n  array.forEach(number => result += number);\n  return result;\n}\n```\n\nNothing wrong about it, but we still need a `result` tmp var.\n\n\n### Array.prototype.reduce (better)\n\n``` javascript\n// array = [1,2,3,4]\nfunction sum(array) {\n  return array.reduce((pre, cur) => {\n    return pre + cur;\n  });\n}\n```\n\nthis it the killer function of javascript, reduce function simply turns a `collection` in to a single value.\n\n<div class=\"tip\">\nRemember, you MUST return the accumulated result in the reducer function\n</div>\n\nWe finally get rid of the annoying tmp var `result`! Yeal~\n\n\n### \\_.sum (best)\n\n``` javascript\n// array = [1,2,3,4]\nfunction sum(array) {\n  return _.sum(array);\n}\n```\n\nThe real killer in JavaScript is the `lodash` library. It has became the de-factor JavaScript utility library. So Whenever you starts to write a function, the first thing to come up is always:\n\ncan i achieve it in lodash?\n\ncan i achieve it in lodash?\n\ncan i achieve it in lodash?\n\n(have to repeat 3 times to emphersize important things)\n\n<div class=\"tip\">\nAlways exploring lodash for data transformation tasks\n</div>\n\n## `clean` function\n\nconsider the `clean` function here:\n\n``` javascript\n// ['tag1', 'tag2', 'tag1  '] -> ['tag1', 'tag2']\nfunction clean(tags) {\n  let dedupe = {};\n  for (let i = 0; i < tags.length; i++){\n    tags[i] = tags[i].trim();\n    const aTag = tags[i];\n\n    if(dedupe[aTag]) {\n      tags.splice(i, 1);\n      i--;\n    } else {\n      dedupe[aTag] = true;\n    }\n  }\n  return tags;\n}\n```\n\nit takes some time to brain-parse this function, it seems to work but it has a potential bug: it changes the reference of the argument passed in.\n\n### impurity\n\n``` diff\n// ['tag1', 'tag2', 'tag1  '] -> ['tag1', 'tag2']\nfunction clean(tags) {\n  let dedupe = {};\n  for (let i = 0; i < tags.length; i++){\n-    tags[i] = tags[i].trim(); // mutates the tags\n    const aTag = tags[i];\n\n    if(dedupe[aTag]) {\n-      tags.splice(i, 1); // mutates the tags\n      i--;\n    } else {\n      dedupe[aTag] = true;\n    }\n  }\n  return tags;\n}\n```\n\nwithout mentioning the mysterious `splice` method with a dynamic `i` variable you need to brain-parse, the highlighted 2 lines are directly mutating the argument.\n\nImagine the `tags` argument passed in could be used in somewhere else, then this function has a side effect that is really hard to predict and could lead to a bug that is extremely hard to trace.\n\nThis is called `side effect` in functional programming world. and the `clean` function above is defined as `impure`\n\n### pure function\nSo we could come up with a better solution:\n\n``` diff\n// ['tag1', 'tag2', 'tag1  '] -> ['tag1', 'tag2']\nfunction clean(tags) {\n  let dedupe = {};\n+ let result = [];\n  for (let i = 0; i < tags.length; i++){\n-   tags[i] = tags[i].trim(); // mutates the tags\n+   const aTag = tags[i].trim();\n\n    if(dedupe[aTag]) {\n-     tags.splice(i, 1); // mutates the tags\n-     i--;\n+     result.push(aTag);\n    } else {\n      dedupe[aTag] = true;\n    }\n  }\n  return tags;\n}\n```\n\nwith this implementation, at least we have get rid of the side effects and eliminated a potential caused by direct data mutation, but we could still do better:\n\n### Concatenated loops\n\n{% asset_img \"loop-patterns.png\" \"Loop patterns\" %}\n\nAs illustrated in the image above, generally a good practice is try to wring `Concatenated loop`.\n\nTo achieve this goal, we could follow a simple rule:\n\n> Inside loop, try to do only 1 thing\n\ntry to apply that to the `clean` function, we could get\n\n``` javascript\n// ['tag1', 'tag2', 'tag1'] -> ['tag1', 'tag2']\nfunction clean(tags) {\n  let dedupe = {};\n  let result = [];\n\n  for (let i = 0; i < tags.length; i++) {\n    dedupe[tags[i].trim()] = true;\n  }\n\n  for (let i = 0; i < tags.length; i++) {\n    if (dedupe[tags[i].trim()]) {\n      result.push(tags[i])\n    }\n  }\n\n  return result;\n}\n```\n\nHere inside those 2 loops, we could easily figure out what they are doing respectively.\n\n\n### Lazy evaluation\n\nHowever, some people may ask: this is a `O(2n)` compared to the previous `O(n)` function.\n\nHere will introduce the killer feature of `lodash` - chainable api\n\nit is basically implemented using `_.chain(collection)` method, or `_(collection)` as a shorthand, and could be optimized easily\n\n``` javascript\nconst result = _(source).map(func1).map(func2).map(func3).value();\n```\n\nis transformed to something like following in normal mode.\n\n``` javascript\nlet result = [], temp1 = [], temp2 = [], temp3 = [];\n\nfor (var i = 0; i < source.length; i++) {\n temp1[i] = func1(source[i]);\n}\n\nfor (i = 0; i < source.length; i++) {\n temp2[i] = func2(temp1[i]);\n}\n\nfor (i = 0; i < source.length; i++) {\n temp3[i] = func3(temp2[i]);\n}\n\nresult = temp3;\n```\n\nBut in the lazy mode (could be accomplished with `lazy.js`):\n\n``` javascript\nlet result = [];\nfor (var i = 0; i < source.length; i++) {\n  result[i] = func3(func2(func1(source[i])));\n}\n```\n\nas you could see, `O(kn)` algorithm has been optimized to `O(n)`. With pure `for` loop, this optimization is not easy to be achived, but with `lodash` and a sequence of function transformation, this could be easily achieved.\n\n### Lodash Chainable API: rewrite `clean` function\n\n``` javascript\n// ['tag1', 'tag2  ', 'tag1 '] -> ['tag1', 'tag2']\nfunction clean(tags) {\n  return _(tags)\n    .map(_.trim)\n    .uniq()\n    .value();\n}\n```\n\nthis is so much cleaner than the first version of above!\n\nread the documentation on [lodash chain](https://lodash.com/docs/4.17.2#chain) for more black magic\n\n## `mergeAndOverwrite` function\n\nconsider the function below:\n\n``` javascript\nfunction mergeAndOverwrite(target, source) {\n  target = _.merge(_.cloneDeep(target), source.merge);\n\n  for (let config_key in source.overwrite) {\n    if (source.overwrite.hasOwnProperty(config_key)) {\n      target[config_key] = source.overwrite[config_key];\n    }\n  }\n\n  return target;\n}\n```\n\nthere are 2 gotchas:\n1. 1st parameter in `_.merge` could be an empty object, and `_.merge` is a recursive deep operation already, so `_.cloneDeep` is somewhat a cumbersome call.\n2. the for ... in loop could be entirely replaced by `Object.assign`\n\n\n### \\_.merge vs Object.assign\n\nThose 2 functions are similar but do things in totally different ways:\n\n1. \\.merge is a recursive call, so it traverses **every** property all object and merge them\n2. Object.assign only overwrite the 1st layer of right hand-side to left hands-side\n\n``` javascript\n// => { \"a\": { \"a\": \"a\",\"b\":\"bb\" }}\n_.merge({}, {a:{a:'a'}}, {a:{b:'bb'}})\n// => { \"a\": { \"b\": \"bb\" }}\nObject.assign({}, {a:{a:'a'}}, {a:{b:'bb'}})\n\n// => { \"a\": [ \"bb\" ] }\n_.merge({}, {a:['a']}, {a:['bb']})\n// => { \"a\": [ \"bb\" ] }\nObject.assign({}, {a:['a']}, {a:['bb']})\n```\n\n### rewrite the `mergeAndOverwrite` function\n\n``` javascript\nfunction mergeAndOverwrite(target, source) {\n  const merged = _.merge(\n    {},\n    target,\n    source.merge\n  );\n  return Object.assign(\n    merged,\n    source.overwrite\n  );\n}\n```\n\n<div class=\"tip\">\nRead through Lodash doc before using \\_.cloneDeep\n</div>\n\n## Final challenge: indentation hell\n\nTo wrap up, consider the following function\n\n``` javascript\nfunction filterAck(acl_hash) {\n  // 0\n  let filtered_api_acl = {};\n  for (let api_version in acl_hash) {\n    // 1\n    if (acl_hash.hasOwnProperty(api_version)) {\n      // 2\n      if (config.api_key.default_user_api_acl[api_version]) {\n        // 3\n        filtered_api_acl[api_version] = [];\n        if (_.isArray(acl_hash[api_version])) {\n          // 4\n          for (let i = 0; i < acl_hash[api_version].length; i++) {\n            // 5\n            if (config.api_key.default_user_api_acl[api_version].indexOf(acl_hash[api_version][i]) !== -1) {\n              // 6\n              filtered_api_acl[api_version].push(acl_hash[api_version][i]);\n            }\n          }\n        }\n      }\n    }\n  }\n  return filtered_api_acl;\n}\n```\n\n<div class=\"tip\">\nWe human beings are not good at reading deeply nested indentation hells: Research shows we only have 7 buffers for short term memory... So code like below will literally burn our brain out.\n</div>\n\n{% asset_img \"indentation-hell.jpg\" \"indentation hell\" %}\n\nWhenever writing code, try your best to keep the indentation level <= 3 is generally a good practice, **this could vastly improve maintainability of code.**\n\n### 1. use `Object.keys` to iterate an object\n\nindentation level `-1`, current `5`\n\n``` diff\nfunction filterAck(acl_hash) {\n  let filtered_api_acl = {};\n- for (let api_version in acl_hash) {\n-   if (acl_hash.hasOwnProperty(api_version)) {\n+ Object.keys(acl_hash).forEach(api_version => {\n-     if (config.api_key.default_user_api_acl[api_version]) {\n+   if (config.api_key.default_user_api_acl[api_version]) {\n-       filtered_api_acl[api_version] = [];\n+     filtered_api_acl[api_version] = [];\n-       if (_.isArray(acl_hash[api_version])) {\n+     if (_.isArray(acl_hash[api_version])) {\n-         for (let i = 0; i < acl_hash[api_version].length; i++) {\n+       for (let i = 0; i < acl_hash[api_version].length; i++) {\n-           if (config.api_key.default_user_api_acl[api_version].indexOf(acl_hash[api_version][i]) !== -1) {\n+         if (config.api_key.default_user_api_acl[api_version].indexOf(acl_hash[api_version][i]) !== -1) {\n-             filtered_api_acl[api_version].push(acl_hash[api_version][i]);\n            // 5\n+           filtered_api_acl[api_version].push(acl_hash[api_version][i]);\n-           }\n+         }\n-         }\n+       }\n-       }\n+     }\n-     }\n+   }\n- }\n+ });\n  return filtered_api_acl;\n}\n```\n\n### 2. use `_.intersction` to simplify replace the inner loop\n\nindentation level `-2`, current: `3`\n\n``` diff\nfunction filterAcl(acl_hash) {\n  let filtered_api_acl = {};\n  Object.keys(acl_hash).forEach(api_version => {\n    if (config.api_key.default_user_api_acl[api_version]) {\n+     filtered_api_acl[api_version] = [];\n      if (_.isArray(acl_hash[api_version])) {\n-       for (let i = 0; i < acl_hash[api_version].length; i++) {\n-         if (config.api_key.default_user_api_acl[api_version].indexOf(acl_hash[api_version][i]) !== -1) {\n-           filtered_api_acl[api_version].push(acl_hash[api_version][i]);\n-         }\n-       }\n        // 3\n+       filtered_api_acl[api_version] = _.intersction(\n+         config.api_key.default_user_api_acl[api_version],\n+         acl_hash\n+       )\n      }\n    }\n  })\n  return filtered_api_acl;\n}\n```\n\n### 3. return in advance to reduce indentation level\n\nindentation level `-1`, current `2`\n\n``` javascript\nfunction filterAcl(acl_hash) {\n  let filtered_api_acl = {};\n  Object.keys(acl_hash).forEach(api_version => {\n    if (!config.api_key.default_user_api_acl[api_version]) {\n      // 2\n      return;\n    }\n\n    if (!_.isArray(acl_hash[api_version])) {\n      return;\n    }\n\n    filtered_api_acl[api_version] = [];\n\n    filtered_api_acl[api_version] = _.intersection(\n      config.api_key.default_user_api_acl[api_version],\n      acl_hash[api_version]\n    );\n  });\n\n  return filtered_api_acl;\n}\n```\n\n### 4. final step: use lodash to wrap everything\n\nindentation level `-2`, current `0`\n\n``` javascript\nfunction filterAcl(acl_hash) {\n  return _\n    .chain(Object.keys(acl_hash))\n    .filter(api_version => config.api_key.default_user_api_acl[api_version])\n    .filter(api_version => Array.isArray(acl_hash[api_version]))\n    .map(api_version => ([\n      api_version,\n      _.intersection(\n        config.api_key.default_user_api_acl,\n        acl_hash[api_version]\n      )\n    ]))\n    .fromPairs()\n    .value();\n}\n```\n\n## Final Words\n\n<div class=\"tip\">\nUse Lodash!\n</div>\n\n#### references:\n\n* [lodash-doc](https://lodash.com/docs/4.17.2)\n* [lazy-js-intro](http://philosopherdeveloper.com/posts/introducing-lazy-js.html)\n* [for-in-stackoverflow](http://stackoverflow.com/questions/500504/why-is-using-for-in-with-array-iteration-a-bad-idea)\n* [simple-rules-for-simple-code](https://laracasts.com/series/simple-rules-for-simpler-code)\n","slug":"javascript-102","published":1,"updated":"2016-12-19T18:09:31.000Z","_id":"ciwwar0jl0000gqgf2ijk87ga","comments":1,"layout":"post","photos":[],"link":"","content":"<p>JavaScript is essential to companies using <code>Node.js</code>. It’s THE language of year 2016. However, it is also a fragile language could be easily abused.</p>\n<a id=\"more\"></a>\n<h2 id=\"Road-toward-clean-code-less-bug\"><a href=\"#Road-toward-clean-code-less-bug\" class=\"headerlink\" title=\"Road toward clean code (less bug)\"></a>Road toward clean code (less bug)</h2><p>In this article, I am going to demonstrate some best practices in JavaScript with examples.</p>\n<h2 id=\"sum-function\"><a href=\"#sum-function\" class=\"headerlink\" title=\"sum function\"></a><code>sum</code> function</h2><p>To begin with, we are required to write a simple sum function. Here is the requirement:</p>\n<ol>\n<li>the function accepts <strong>1</strong> argument - an array of numbers</li>\n<li>the function should return the sum of all the numbers inside the array</li>\n</ol>\n<h3 id=\"for-loop-not-recommended\"><a href=\"#for-loop-not-recommended\" class=\"headerlink\" title=\"for loop (not recommended)\"></a>for loop (not recommended)</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// array = [1,2,3,4]</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sum</span>(<span class=\"params\">array</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">let</span> result = <span class=\"number\">0</span>;</div><div class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; array.length; i++) &#123;</div><div class=\"line\">    result += array[i];</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> result;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>The first approach is intuitive: use traditional <code>for</code> loop. There is nothing wrong about it, but as a js developer, we could do better.</p>\n<h3 id=\"for-…-in-loop-DEPRECATED-DO-NOT-USE\"><a href=\"#for-…-in-loop-DEPRECATED-DO-NOT-USE\" class=\"headerlink\" title=\"for … in loop (DEPRECATED, DO NOT USE)\"></a>for … in loop (<strong>DEPRECATED</strong>, DO NOT USE)</h3><p>And here is the famous <code>foo ... in</code> loop.</p>\n<p>As you can see, the obvious drawback of <code>for ... in</code> loop is that it could iterate over all of the keys and all the keys on it’s prototype chain inside an object (array is also an object in js), therefore we have this <code>hasOwnProperty</code> check.</p>\n<p>an astonishing fact is that a lot of programmers from other languages really love this approach… However, the cold fact is due to the cumbersome <code>hasOwnProperty</code> check, <code>for ... in</code> loop is seldom used in most of the <code>Node.js</code> project, and even considered bad practice when iterate over a collection.</p>\n<p>Here is the reason:</p>\n<blockquote>\n<p> The for-in statement by itself is not a “bad practice”, however it can be mis-used, for example, to iterate over arrays or array-like objects.</p>\n<p>The purpose of the for-in statement is to enumerate over object properties. This statement will go up in the prototype chain, also enumerating over inherited properties, a thing that sometimes is not desired.</p>\n<p>Also, the order of iteration is not guaranteed by the spec., meaning that if you want to “iterate” an array object, with this statement you cannot be sure that the properties (array indexes) will be visited in the numeric order.</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// array = [1,2,3,4]</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sum</span>(<span class=\"params\">array</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">let</span> result = <span class=\"number\">0</span>;</div><div class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> index <span class=\"keyword\">in</span> array) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (array.hasOwnProperty(index)) &#123;</div><div class=\"line\">      result += array[index];</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> result;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>If one should iterate over every property in an <code>object</code> (<code>{}</code>) rather than <code>array</code> (<code>[]</code>), consider use those methods:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">Object</span>.keys           &lt;-&gt; _.keys</div><div class=\"line\"><span class=\"built_in\">Object</span>.values  (es7)  &lt;-&gt; _.values</div><div class=\"line\"><span class=\"built_in\">Object</span>.entries (es7)  &lt;-&gt; _.pairs</div></pre></td></tr></table></figure>\n<p>Those methods are not following the prototype chain to do an exhaustive search so they may even have better performance compared to the <code>for ... in</code> loop.</p>\n<h3 id=\"for-…-of-loop-es6-Okay-not-the-best\"><a href=\"#for-…-of-loop-es6-Okay-not-the-best\" class=\"headerlink\" title=\"for … of loop (es6) (Okay.. not the best)\"></a>for … of loop (es6) (Okay.. not the best)</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// array = [1,2,3,4]</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sum</span>(<span class=\"params\">array</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">let</span> result = <span class=\"number\">0</span>;</div><div class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> number <span class=\"keyword\">of</span> array) &#123;</div><div class=\"line\">    result += number;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> result;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>this is a more recommended way to iterate a collection (or iterable to be precise).</p>\n<p><code>for ... of</code> will not follow the prototype chain as well, because it can only be used on <code>iterable object</code>. And <code>Array</code> in es6 is implemented as an iterable. <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators\" target=\"_blank\" rel=\"external\">iterable-mdn</a></p>\n<h3 id=\"Array-prototype-forEach-Okay-not-the-best\"><a href=\"#Array-prototype-forEach-Okay-not-the-best\" class=\"headerlink\" title=\"Array.prototype.forEach (Okay, not the best)\"></a>Array.prototype.forEach (Okay, not the best)</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// array = [1,2,3,4]</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sum</span>(<span class=\"params\">array</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">let</span> result = <span class=\"number\">0</span>;</div><div class=\"line\">  array.forEach(<span class=\"function\"><span class=\"params\">number</span> =&gt;</span> result += number);</div><div class=\"line\">  <span class=\"keyword\">return</span> result;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Nothing wrong about it, but we still need a <code>result</code> tmp var.</p>\n<h3 id=\"Array-prototype-reduce-better\"><a href=\"#Array-prototype-reduce-better\" class=\"headerlink\" title=\"Array.prototype.reduce (better)\"></a>Array.prototype.reduce (better)</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// array = [1,2,3,4]</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sum</span>(<span class=\"params\">array</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> array.reduce(<span class=\"function\">(<span class=\"params\">pre, cur</span>) =&gt;</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> pre + cur;</div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>this it the killer function of javascript, reduce function simply turns a <code>collection</code> in to a single value.</p>\n<div class=\"tip\"><br>Remember, you MUST return the accumulated result in the reducer function<br></div>\n\n<p>We finally get rid of the annoying tmp var <code>result</code>! Yeal~</p>\n<h3 id=\"sum-best\"><a href=\"#sum-best\" class=\"headerlink\" title=\"_.sum (best)\"></a>_.sum (best)</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// array = [1,2,3,4]</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sum</span>(<span class=\"params\">array</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> _.sum(array);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>The real killer in JavaScript is the <code>lodash</code> library. It has became the de-factor JavaScript utility library. So Whenever you starts to write a function, the first thing to come up is always:</p>\n<p>can i achieve it in lodash?</p>\n<p>can i achieve it in lodash?</p>\n<p>can i achieve it in lodash?</p>\n<p>(have to repeat 3 times to emphersize important things)</p>\n<div class=\"tip\"><br>Always exploring lodash for data transformation tasks<br></div>\n\n<h2 id=\"clean-function\"><a href=\"#clean-function\" class=\"headerlink\" title=\"clean function\"></a><code>clean</code> function</h2><p>consider the <code>clean</code> function here:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// ['tag1', 'tag2', 'tag1  '] -&gt; ['tag1', 'tag2']</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">clean</span>(<span class=\"params\">tags</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">let</span> dedupe = &#123;&#125;;</div><div class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; tags.length; i++)&#123;</div><div class=\"line\">    tags[i] = tags[i].trim();</div><div class=\"line\">    <span class=\"keyword\">const</span> aTag = tags[i];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span>(dedupe[aTag]) &#123;</div><div class=\"line\">      tags.splice(i, <span class=\"number\">1</span>);</div><div class=\"line\">      i--;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      dedupe[aTag] = <span class=\"literal\">true</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> tags;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>it takes some time to brain-parse this function, it seems to work but it has a potential bug: it changes the reference of the argument passed in.</p>\n<h3 id=\"impurity\"><a href=\"#impurity\" class=\"headerlink\" title=\"impurity\"></a>impurity</h3><figure class=\"highlight diff\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">// ['tag1', 'tag2', 'tag1  '] -&gt; ['tag1', 'tag2']</div><div class=\"line\">function clean(tags) &#123;</div><div class=\"line\">  let dedupe = &#123;&#125;;</div><div class=\"line\">  for (let i = 0; i &lt; tags.length; i++)&#123;</div><div class=\"line\"><span class=\"deletion\">-    tags[i] = tags[i].trim(); // mutates the tags</span></div><div class=\"line\">    const aTag = tags[i];</div><div class=\"line\"></div><div class=\"line\">    if(dedupe[aTag]) &#123;</div><div class=\"line\"><span class=\"deletion\">-      tags.splice(i, 1); // mutates the tags</span></div><div class=\"line\">      i--;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">      dedupe[aTag] = true;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  return tags;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>without mentioning the mysterious <code>splice</code> method with a dynamic <code>i</code> variable you need to brain-parse, the highlighted 2 lines are directly mutating the argument.</p>\n<p>Imagine the <code>tags</code> argument passed in could be used in somewhere else, then this function has a side effect that is really hard to predict and could lead to a bug that is extremely hard to trace.</p>\n<p>This is called <code>side effect</code> in functional programming world. and the <code>clean</code> function above is defined as <code>impure</code></p>\n<h3 id=\"pure-function\"><a href=\"#pure-function\" class=\"headerlink\" title=\"pure function\"></a>pure function</h3><p>So we could come up with a better solution:</p>\n<figure class=\"highlight diff\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">// ['tag1', 'tag2', 'tag1  '] -&gt; ['tag1', 'tag2']</div><div class=\"line\">function clean(tags) &#123;</div><div class=\"line\">  let dedupe = &#123;&#125;;</div><div class=\"line\"><span class=\"addition\">+ let result = [];</span></div><div class=\"line\">  for (let i = 0; i &lt; tags.length; i++)&#123;</div><div class=\"line\"><span class=\"deletion\">-   tags[i] = tags[i].trim(); // mutates the tags</span></div><div class=\"line\"><span class=\"addition\">+   const aTag = tags[i].trim();</span></div><div class=\"line\"></div><div class=\"line\">    if(dedupe[aTag]) &#123;</div><div class=\"line\"><span class=\"deletion\">-     tags.splice(i, 1); // mutates the tags</span></div><div class=\"line\"><span class=\"deletion\">-     i--;</span></div><div class=\"line\"><span class=\"addition\">+     result.push(aTag);</span></div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">      dedupe[aTag] = true;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  return tags;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>with this implementation, at least we have get rid of the side effects and eliminated a potential caused by direct data mutation, but we could still do better:</p>\n<h3 id=\"Concatenated-loops\"><a href=\"#Concatenated-loops\" class=\"headerlink\" title=\"Concatenated loops\"></a>Concatenated loops</h3><img src=\"/2016/12/19/javascript-102/loop-patterns.png\" alt=\"Loop patterns\" title=\"Loop patterns\">\n<p>As illustrated in the image above, generally a good practice is try to wring <code>Concatenated loop</code>.</p>\n<p>To achieve this goal, we could follow a simple rule:</p>\n<blockquote>\n<p>Inside loop, try to do only 1 thing</p>\n</blockquote>\n<p>try to apply that to the <code>clean</code> function, we could get</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// ['tag1', 'tag2', 'tag1'] -&gt; ['tag1', 'tag2']</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">clean</span>(<span class=\"params\">tags</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">let</span> dedupe = &#123;&#125;;</div><div class=\"line\">  <span class=\"keyword\">let</span> result = [];</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; tags.length; i++) &#123;</div><div class=\"line\">    dedupe[tags[i].trim()] = <span class=\"literal\">true</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; tags.length; i++) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (dedupe[tags[i].trim()]) &#123;</div><div class=\"line\">      result.push(tags[i])</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">return</span> result;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Here inside those 2 loops, we could easily figure out what they are doing respectively.</p>\n<h3 id=\"Lazy-evaluation\"><a href=\"#Lazy-evaluation\" class=\"headerlink\" title=\"Lazy evaluation\"></a>Lazy evaluation</h3><p>However, some people may ask: this is a <code>O(2n)</code> compared to the previous <code>O(n)</code> function.</p>\n<p>Here will introduce the killer feature of <code>lodash</code> - chainable api</p>\n<p>it is basically implemented using <code>_.chain(collection)</code> method, or <code>_(collection)</code> as a shorthand, and could be optimized easily</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> result = _(source).map(func1).map(func2).map(func3).value();</div></pre></td></tr></table></figure>\n<p>is transformed to something like following in normal mode.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> result = [], temp1 = [], temp2 = [], temp3 = [];</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; source.length; i++) &#123;</div><div class=\"line\"> temp1[i] = func1(source[i]);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; source.length; i++) &#123;</div><div class=\"line\"> temp2[i] = func2(temp1[i]);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; source.length; i++) &#123;</div><div class=\"line\"> temp3[i] = func3(temp2[i]);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">result = temp3;</div></pre></td></tr></table></figure>\n<p>But in the lazy mode (could be accomplished with <code>lazy.js</code>):</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> result = [];</div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; source.length; i++) &#123;</div><div class=\"line\">  result[i] = func3(func2(func1(source[i])));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>as you could see, <code>O(kn)</code> algorithm has been optimized to <code>O(n)</code>. With pure <code>for</code> loop, this optimization is not easy to be achived, but with <code>lodash</code> and a sequence of function transformation, this could be easily achieved.</p>\n<h3 id=\"Lodash-Chainable-API-rewrite-clean-function\"><a href=\"#Lodash-Chainable-API-rewrite-clean-function\" class=\"headerlink\" title=\"Lodash Chainable API: rewrite clean function\"></a>Lodash Chainable API: rewrite <code>clean</code> function</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// ['tag1', 'tag2  ', 'tag1 '] -&gt; ['tag1', 'tag2']</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">clean</span>(<span class=\"params\">tags</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> _(tags)</div><div class=\"line\">    .map(_.trim)</div><div class=\"line\">    .uniq()</div><div class=\"line\">    .value();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>this is so much cleaner than the first version of above!</p>\n<p>read the documentation on <a href=\"https://lodash.com/docs/4.17.2#chain\" target=\"_blank\" rel=\"external\">lodash chain</a> for more black magic</p>\n<h2 id=\"mergeAndOverwrite-function\"><a href=\"#mergeAndOverwrite-function\" class=\"headerlink\" title=\"mergeAndOverwrite function\"></a><code>mergeAndOverwrite</code> function</h2><p>consider the function below:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mergeAndOverwrite</span>(<span class=\"params\">target, source</span>) </span>&#123;</div><div class=\"line\">  target = _.merge(_.cloneDeep(target), source.merge);</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> config_key <span class=\"keyword\">in</span> source.overwrite) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (source.overwrite.hasOwnProperty(config_key)) &#123;</div><div class=\"line\">      target[config_key] = source.overwrite[config_key];</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">return</span> target;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>there are 2 gotchas:</p>\n<ol>\n<li>1st parameter in <code>_.merge</code> could be an empty object, and <code>_.merge</code> is a recursive deep operation already, so <code>_.cloneDeep</code> is somewhat a cumbersome call.</li>\n<li>the for … in loop could be entirely replaced by <code>Object.assign</code></li>\n</ol>\n<h3 id=\"merge-vs-Object-assign\"><a href=\"#merge-vs-Object-assign\" class=\"headerlink\" title=\"_.merge vs Object.assign\"></a>_.merge vs Object.assign</h3><p>Those 2 functions are similar but do things in totally different ways:</p>\n<ol>\n<li>.merge is a recursive call, so it traverses <strong>every</strong> property all object and merge them</li>\n<li>Object.assign only overwrite the 1st layer of right hand-side to left hands-side</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// =&gt; &#123; \"a\": &#123; \"a\": \"a\",\"b\":\"bb\" &#125;&#125;</span></div><div class=\"line\">_.merge(&#123;&#125;, &#123;<span class=\"attr\">a</span>:&#123;<span class=\"attr\">a</span>:<span class=\"string\">'a'</span>&#125;&#125;, &#123;<span class=\"attr\">a</span>:&#123;<span class=\"attr\">b</span>:<span class=\"string\">'bb'</span>&#125;&#125;)</div><div class=\"line\"><span class=\"comment\">// =&gt; &#123; \"a\": &#123; \"b\": \"bb\" &#125;&#125;</span></div><div class=\"line\"><span class=\"built_in\">Object</span>.assign(&#123;&#125;, &#123;<span class=\"attr\">a</span>:&#123;<span class=\"attr\">a</span>:<span class=\"string\">'a'</span>&#125;&#125;, &#123;<span class=\"attr\">a</span>:&#123;<span class=\"attr\">b</span>:<span class=\"string\">'bb'</span>&#125;&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// =&gt; &#123; \"a\": [ \"bb\" ] &#125;</span></div><div class=\"line\">_.merge(&#123;&#125;, &#123;<span class=\"attr\">a</span>:[<span class=\"string\">'a'</span>]&#125;, &#123;<span class=\"attr\">a</span>:[<span class=\"string\">'bb'</span>]&#125;)</div><div class=\"line\"><span class=\"comment\">// =&gt; &#123; \"a\": [ \"bb\" ] &#125;</span></div><div class=\"line\"><span class=\"built_in\">Object</span>.assign(&#123;&#125;, &#123;<span class=\"attr\">a</span>:[<span class=\"string\">'a'</span>]&#125;, &#123;<span class=\"attr\">a</span>:[<span class=\"string\">'bb'</span>]&#125;)</div></pre></td></tr></table></figure>\n<h3 id=\"rewrite-the-mergeAndOverwrite-function\"><a href=\"#rewrite-the-mergeAndOverwrite-function\" class=\"headerlink\" title=\"rewrite the mergeAndOverwrite function\"></a>rewrite the <code>mergeAndOverwrite</code> function</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mergeAndOverwrite</span>(<span class=\"params\">target, source</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">const</span> merged = _.merge(</div><div class=\"line\">    &#123;&#125;,</div><div class=\"line\">    target,</div><div class=\"line\">    source.merge</div><div class=\"line\">  );</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.assign(</div><div class=\"line\">    merged,</div><div class=\"line\">    source.overwrite</div><div class=\"line\">  );</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<div class=\"tip\"><br>Read through Lodash doc before using _.cloneDeep<br></div>\n\n<h2 id=\"Final-challenge-indentation-hell\"><a href=\"#Final-challenge-indentation-hell\" class=\"headerlink\" title=\"Final challenge: indentation hell\"></a>Final challenge: indentation hell</h2><p>To wrap up, consider the following function</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">filterAck</span>(<span class=\"params\">acl_hash</span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// 0</span></div><div class=\"line\">  <span class=\"keyword\">let</span> filtered_api_acl = &#123;&#125;;</div><div class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> api_version <span class=\"keyword\">in</span> acl_hash) &#123;</div><div class=\"line\">    <span class=\"comment\">// 1</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (acl_hash.hasOwnProperty(api_version)) &#123;</div><div class=\"line\">      <span class=\"comment\">// 2</span></div><div class=\"line\">      <span class=\"keyword\">if</span> (config.api_key.default_user_api_acl[api_version]) &#123;</div><div class=\"line\">        <span class=\"comment\">// 3</span></div><div class=\"line\">        filtered_api_acl[api_version] = [];</div><div class=\"line\">        <span class=\"keyword\">if</span> (_.isArray(acl_hash[api_version])) &#123;</div><div class=\"line\">          <span class=\"comment\">// 4</span></div><div class=\"line\">          <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; acl_hash[api_version].length; i++) &#123;</div><div class=\"line\">            <span class=\"comment\">// 5</span></div><div class=\"line\">            <span class=\"keyword\">if</span> (config.api_key.default_user_api_acl[api_version].indexOf(acl_hash[api_version][i]) !== <span class=\"number\">-1</span>) &#123;</div><div class=\"line\">              <span class=\"comment\">// 6</span></div><div class=\"line\">              filtered_api_acl[api_version].push(acl_hash[api_version][i]);</div><div class=\"line\">            &#125;</div><div class=\"line\">          &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> filtered_api_acl;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<div class=\"tip\"><br>We human beings are not good at reading deeply nested indentation hells: Research shows we only have 7 buffers for short term memory… So code like below will literally burn our brain out.<br></div>\n\n<img src=\"/2016/12/19/javascript-102/indentation-hell.jpg\" alt=\"indentation hell\" title=\"indentation hell\">\n<p>Whenever writing code, try your best to keep the indentation level &lt;= 3 is generally a good practice, <strong>this could vastly improve maintainability of code.</strong></p>\n<h3 id=\"1-use-Object-keys-to-iterate-an-object\"><a href=\"#1-use-Object-keys-to-iterate-an-object\" class=\"headerlink\" title=\"1. use Object.keys to iterate an object\"></a>1. use <code>Object.keys</code> to iterate an object</h3><p>indentation level <code>-1</code>, current <code>5</code></p>\n<figure class=\"highlight diff\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\">function filterAck(acl_hash) &#123;</div><div class=\"line\">  let filtered_api_acl = &#123;&#125;;</div><div class=\"line\"><span class=\"deletion\">- for (let api_version in acl_hash) &#123;</span></div><div class=\"line\"><span class=\"deletion\">-   if (acl_hash.hasOwnProperty(api_version)) &#123;</span></div><div class=\"line\"><span class=\"addition\">+ Object.keys(acl_hash).forEach(api_version =&gt; &#123;</span></div><div class=\"line\"><span class=\"deletion\">-     if (config.api_key.default_user_api_acl[api_version]) &#123;</span></div><div class=\"line\"><span class=\"addition\">+   if (config.api_key.default_user_api_acl[api_version]) &#123;</span></div><div class=\"line\"><span class=\"deletion\">-       filtered_api_acl[api_version] = [];</span></div><div class=\"line\"><span class=\"addition\">+     filtered_api_acl[api_version] = [];</span></div><div class=\"line\"><span class=\"deletion\">-       if (_.isArray(acl_hash[api_version])) &#123;</span></div><div class=\"line\"><span class=\"addition\">+     if (_.isArray(acl_hash[api_version])) &#123;</span></div><div class=\"line\"><span class=\"deletion\">-         for (let i = 0; i &lt; acl_hash[api_version].length; i++) &#123;</span></div><div class=\"line\"><span class=\"addition\">+       for (let i = 0; i &lt; acl_hash[api_version].length; i++) &#123;</span></div><div class=\"line\"><span class=\"deletion\">-           if (config.api_key.default_user_api_acl[api_version].indexOf(acl_hash[api_version][i]) !== -1) &#123;</span></div><div class=\"line\"><span class=\"addition\">+         if (config.api_key.default_user_api_acl[api_version].indexOf(acl_hash[api_version][i]) !== -1) &#123;</span></div><div class=\"line\"><span class=\"deletion\">-             filtered_api_acl[api_version].push(acl_hash[api_version][i]);</span></div><div class=\"line\">            // 5</div><div class=\"line\"><span class=\"addition\">+           filtered_api_acl[api_version].push(acl_hash[api_version][i]);</span></div><div class=\"line\"><span class=\"deletion\">-           &#125;</span></div><div class=\"line\"><span class=\"addition\">+         &#125;</span></div><div class=\"line\"><span class=\"deletion\">-         &#125;</span></div><div class=\"line\"><span class=\"addition\">+       &#125;</span></div><div class=\"line\"><span class=\"deletion\">-       &#125;</span></div><div class=\"line\"><span class=\"addition\">+     &#125;</span></div><div class=\"line\"><span class=\"deletion\">-     &#125;</span></div><div class=\"line\"><span class=\"addition\">+   &#125;</span></div><div class=\"line\"><span class=\"deletion\">- &#125;</span></div><div class=\"line\"><span class=\"addition\">+ &#125;);</span></div><div class=\"line\">  return filtered_api_acl;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"2-use-intersction-to-simplify-replace-the-inner-loop\"><a href=\"#2-use-intersction-to-simplify-replace-the-inner-loop\" class=\"headerlink\" title=\"2. use _.intersction to simplify replace the inner loop\"></a>2. use <code>_.intersction</code> to simplify replace the inner loop</h3><p>indentation level <code>-2</code>, current: <code>3</code></p>\n<figure class=\"highlight diff\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">function filterAcl(acl_hash) &#123;</div><div class=\"line\">  let filtered_api_acl = &#123;&#125;;</div><div class=\"line\">  Object.keys(acl_hash).forEach(api_version =&gt; &#123;</div><div class=\"line\">    if (config.api_key.default_user_api_acl[api_version]) &#123;</div><div class=\"line\"><span class=\"addition\">+     filtered_api_acl[api_version] = [];</span></div><div class=\"line\">      if (_.isArray(acl_hash[api_version])) &#123;</div><div class=\"line\"><span class=\"deletion\">-       for (let i = 0; i &lt; acl_hash[api_version].length; i++) &#123;</span></div><div class=\"line\"><span class=\"deletion\">-         if (config.api_key.default_user_api_acl[api_version].indexOf(acl_hash[api_version][i]) !== -1) &#123;</span></div><div class=\"line\"><span class=\"deletion\">-           filtered_api_acl[api_version].push(acl_hash[api_version][i]);</span></div><div class=\"line\"><span class=\"deletion\">-         &#125;</span></div><div class=\"line\"><span class=\"deletion\">-       &#125;</span></div><div class=\"line\">        // 3</div><div class=\"line\"><span class=\"addition\">+       filtered_api_acl[api_version] = _.intersction(</span></div><div class=\"line\"><span class=\"addition\">+         config.api_key.default_user_api_acl[api_version],</span></div><div class=\"line\"><span class=\"addition\">+         acl_hash</span></div><div class=\"line\"><span class=\"addition\">+       )</span></div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;)</div><div class=\"line\">  return filtered_api_acl;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"3-return-in-advance-to-reduce-indentation-level\"><a href=\"#3-return-in-advance-to-reduce-indentation-level\" class=\"headerlink\" title=\"3. return in advance to reduce indentation level\"></a>3. return in advance to reduce indentation level</h3><p>indentation level <code>-1</code>, current <code>2</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">filterAcl</span>(<span class=\"params\">acl_hash</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">let</span> filtered_api_acl = &#123;&#125;;</div><div class=\"line\">  <span class=\"built_in\">Object</span>.keys(acl_hash).forEach(<span class=\"function\"><span class=\"params\">api_version</span> =&gt;</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (!config.api_key.default_user_api_acl[api_version]) &#123;</div><div class=\"line\">      <span class=\"comment\">// 2</span></div><div class=\"line\">      <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (!_.isArray(acl_hash[api_version])) &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    filtered_api_acl[api_version] = [];</div><div class=\"line\"></div><div class=\"line\">    filtered_api_acl[api_version] = _.intersection(</div><div class=\"line\">      config.api_key.default_user_api_acl[api_version],</div><div class=\"line\">      acl_hash[api_version]</div><div class=\"line\">    );</div><div class=\"line\">  &#125;);</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">return</span> filtered_api_acl;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"4-final-step-use-lodash-to-wrap-everything\"><a href=\"#4-final-step-use-lodash-to-wrap-everything\" class=\"headerlink\" title=\"4. final step: use lodash to wrap everything\"></a>4. final step: use lodash to wrap everything</h3><p>indentation level <code>-2</code>, current <code>0</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">filterAcl</span>(<span class=\"params\">acl_hash</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> _</div><div class=\"line\">    .chain(<span class=\"built_in\">Object</span>.keys(acl_hash))</div><div class=\"line\">    .filter(<span class=\"function\"><span class=\"params\">api_version</span> =&gt;</span> config.api_key.default_user_api_acl[api_version])</div><div class=\"line\">    .filter(<span class=\"function\"><span class=\"params\">api_version</span> =&gt;</span> <span class=\"built_in\">Array</span>.isArray(acl_hash[api_version]))</div><div class=\"line\">    .map(<span class=\"function\"><span class=\"params\">api_version</span> =&gt;</span> ([</div><div class=\"line\">      api_version,</div><div class=\"line\">      _.intersection(</div><div class=\"line\">        config.api_key.default_user_api_acl,</div><div class=\"line\">        acl_hash[api_version]</div><div class=\"line\">      )</div><div class=\"line\">    ]))</div><div class=\"line\">    .fromPairs()</div><div class=\"line\">    .value();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"Final-Words\"><a href=\"#Final-Words\" class=\"headerlink\" title=\"Final Words\"></a>Final Words</h2><div class=\"tip\"><br>Use Lodash!<br></div>\n\n<h4 id=\"references\"><a href=\"#references\" class=\"headerlink\" title=\"references:\"></a>references:</h4><ul>\n<li><a href=\"https://lodash.com/docs/4.17.2\" target=\"_blank\" rel=\"external\">lodash-doc</a></li>\n<li><a href=\"http://philosopherdeveloper.com/posts/introducing-lazy-js.html\" target=\"_blank\" rel=\"external\">lazy-js-intro</a></li>\n<li><a href=\"http://stackoverflow.com/questions/500504/why-is-using-for-in-with-array-iteration-a-bad-idea\" target=\"_blank\" rel=\"external\">for-in-stackoverflow</a></li>\n<li><a href=\"https://laracasts.com/series/simple-rules-for-simpler-code\" target=\"_blank\" rel=\"external\">simple-rules-for-simple-code</a></li>\n</ul>\n","excerpt":"<p>JavaScript is essential to companies using <code>Node.js</code>. It’s THE language of year 2016. However, it is also a fragile language could be easily abused.</p>","more":"<h2 id=\"Road-toward-clean-code-less-bug\"><a href=\"#Road-toward-clean-code-less-bug\" class=\"headerlink\" title=\"Road toward clean code (less bug)\"></a>Road toward clean code (less bug)</h2><p>In this article, I am going to demonstrate some best practices in JavaScript with examples.</p>\n<h2 id=\"sum-function\"><a href=\"#sum-function\" class=\"headerlink\" title=\"sum function\"></a><code>sum</code> function</h2><p>To begin with, we are required to write a simple sum function. Here is the requirement:</p>\n<ol>\n<li>the function accepts <strong>1</strong> argument - an array of numbers</li>\n<li>the function should return the sum of all the numbers inside the array</li>\n</ol>\n<h3 id=\"for-loop-not-recommended\"><a href=\"#for-loop-not-recommended\" class=\"headerlink\" title=\"for loop (not recommended)\"></a>for loop (not recommended)</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// array = [1,2,3,4]</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sum</span>(<span class=\"params\">array</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">let</span> result = <span class=\"number\">0</span>;</div><div class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; array.length; i++) &#123;</div><div class=\"line\">    result += array[i];</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> result;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>The first approach is intuitive: use traditional <code>for</code> loop. There is nothing wrong about it, but as a js developer, we could do better.</p>\n<h3 id=\"for-…-in-loop-DEPRECATED-DO-NOT-USE\"><a href=\"#for-…-in-loop-DEPRECATED-DO-NOT-USE\" class=\"headerlink\" title=\"for … in loop (DEPRECATED, DO NOT USE)\"></a>for … in loop (<strong>DEPRECATED</strong>, DO NOT USE)</h3><p>And here is the famous <code>foo ... in</code> loop.</p>\n<p>As you can see, the obvious drawback of <code>for ... in</code> loop is that it could iterate over all of the keys and all the keys on it’s prototype chain inside an object (array is also an object in js), therefore we have this <code>hasOwnProperty</code> check.</p>\n<p>an astonishing fact is that a lot of programmers from other languages really love this approach… However, the cold fact is due to the cumbersome <code>hasOwnProperty</code> check, <code>for ... in</code> loop is seldom used in most of the <code>Node.js</code> project, and even considered bad practice when iterate over a collection.</p>\n<p>Here is the reason:</p>\n<blockquote>\n<p> The for-in statement by itself is not a “bad practice”, however it can be mis-used, for example, to iterate over arrays or array-like objects.</p>\n<p>The purpose of the for-in statement is to enumerate over object properties. This statement will go up in the prototype chain, also enumerating over inherited properties, a thing that sometimes is not desired.</p>\n<p>Also, the order of iteration is not guaranteed by the spec., meaning that if you want to “iterate” an array object, with this statement you cannot be sure that the properties (array indexes) will be visited in the numeric order.</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// array = [1,2,3,4]</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sum</span>(<span class=\"params\">array</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">let</span> result = <span class=\"number\">0</span>;</div><div class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> index <span class=\"keyword\">in</span> array) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (array.hasOwnProperty(index)) &#123;</div><div class=\"line\">      result += array[index];</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> result;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>If one should iterate over every property in an <code>object</code> (<code>{}</code>) rather than <code>array</code> (<code>[]</code>), consider use those methods:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">Object</span>.keys           &lt;-&gt; _.keys</div><div class=\"line\"><span class=\"built_in\">Object</span>.values  (es7)  &lt;-&gt; _.values</div><div class=\"line\"><span class=\"built_in\">Object</span>.entries (es7)  &lt;-&gt; _.pairs</div></pre></td></tr></table></figure>\n<p>Those methods are not following the prototype chain to do an exhaustive search so they may even have better performance compared to the <code>for ... in</code> loop.</p>\n<h3 id=\"for-…-of-loop-es6-Okay-not-the-best\"><a href=\"#for-…-of-loop-es6-Okay-not-the-best\" class=\"headerlink\" title=\"for … of loop (es6) (Okay.. not the best)\"></a>for … of loop (es6) (Okay.. not the best)</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// array = [1,2,3,4]</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sum</span>(<span class=\"params\">array</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">let</span> result = <span class=\"number\">0</span>;</div><div class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> number <span class=\"keyword\">of</span> array) &#123;</div><div class=\"line\">    result += number;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> result;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>this is a more recommended way to iterate a collection (or iterable to be precise).</p>\n<p><code>for ... of</code> will not follow the prototype chain as well, because it can only be used on <code>iterable object</code>. And <code>Array</code> in es6 is implemented as an iterable. <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators\">iterable-mdn</a></p>\n<h3 id=\"Array-prototype-forEach-Okay-not-the-best\"><a href=\"#Array-prototype-forEach-Okay-not-the-best\" class=\"headerlink\" title=\"Array.prototype.forEach (Okay, not the best)\"></a>Array.prototype.forEach (Okay, not the best)</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// array = [1,2,3,4]</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sum</span>(<span class=\"params\">array</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">let</span> result = <span class=\"number\">0</span>;</div><div class=\"line\">  array.forEach(<span class=\"function\"><span class=\"params\">number</span> =&gt;</span> result += number);</div><div class=\"line\">  <span class=\"keyword\">return</span> result;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Nothing wrong about it, but we still need a <code>result</code> tmp var.</p>\n<h3 id=\"Array-prototype-reduce-better\"><a href=\"#Array-prototype-reduce-better\" class=\"headerlink\" title=\"Array.prototype.reduce (better)\"></a>Array.prototype.reduce (better)</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// array = [1,2,3,4]</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sum</span>(<span class=\"params\">array</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> array.reduce(<span class=\"function\">(<span class=\"params\">pre, cur</span>) =&gt;</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> pre + cur;</div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>this it the killer function of javascript, reduce function simply turns a <code>collection</code> in to a single value.</p>\n<div class=\"tip\"><br>Remember, you MUST return the accumulated result in the reducer function<br></div>\n\n<p>We finally get rid of the annoying tmp var <code>result</code>! Yeal~</p>\n<h3 id=\"sum-best\"><a href=\"#sum-best\" class=\"headerlink\" title=\"_.sum (best)\"></a>_.sum (best)</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// array = [1,2,3,4]</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sum</span>(<span class=\"params\">array</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> _.sum(array);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>The real killer in JavaScript is the <code>lodash</code> library. It has became the de-factor JavaScript utility library. So Whenever you starts to write a function, the first thing to come up is always:</p>\n<p>can i achieve it in lodash?</p>\n<p>can i achieve it in lodash?</p>\n<p>can i achieve it in lodash?</p>\n<p>(have to repeat 3 times to emphersize important things)</p>\n<div class=\"tip\"><br>Always exploring lodash for data transformation tasks<br></div>\n\n<h2 id=\"clean-function\"><a href=\"#clean-function\" class=\"headerlink\" title=\"clean function\"></a><code>clean</code> function</h2><p>consider the <code>clean</code> function here:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// ['tag1', 'tag2', 'tag1  '] -&gt; ['tag1', 'tag2']</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">clean</span>(<span class=\"params\">tags</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">let</span> dedupe = &#123;&#125;;</div><div class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; tags.length; i++)&#123;</div><div class=\"line\">    tags[i] = tags[i].trim();</div><div class=\"line\">    <span class=\"keyword\">const</span> aTag = tags[i];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span>(dedupe[aTag]) &#123;</div><div class=\"line\">      tags.splice(i, <span class=\"number\">1</span>);</div><div class=\"line\">      i--;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">      dedupe[aTag] = <span class=\"literal\">true</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> tags;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>it takes some time to brain-parse this function, it seems to work but it has a potential bug: it changes the reference of the argument passed in.</p>\n<h3 id=\"impurity\"><a href=\"#impurity\" class=\"headerlink\" title=\"impurity\"></a>impurity</h3><figure class=\"highlight diff\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">// ['tag1', 'tag2', 'tag1  '] -&gt; ['tag1', 'tag2']</div><div class=\"line\">function clean(tags) &#123;</div><div class=\"line\">  let dedupe = &#123;&#125;;</div><div class=\"line\">  for (let i = 0; i &lt; tags.length; i++)&#123;</div><div class=\"line\"><span class=\"deletion\">-    tags[i] = tags[i].trim(); // mutates the tags</span></div><div class=\"line\">    const aTag = tags[i];</div><div class=\"line\"></div><div class=\"line\">    if(dedupe[aTag]) &#123;</div><div class=\"line\"><span class=\"deletion\">-      tags.splice(i, 1); // mutates the tags</span></div><div class=\"line\">      i--;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">      dedupe[aTag] = true;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  return tags;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>without mentioning the mysterious <code>splice</code> method with a dynamic <code>i</code> variable you need to brain-parse, the highlighted 2 lines are directly mutating the argument.</p>\n<p>Imagine the <code>tags</code> argument passed in could be used in somewhere else, then this function has a side effect that is really hard to predict and could lead to a bug that is extremely hard to trace.</p>\n<p>This is called <code>side effect</code> in functional programming world. and the <code>clean</code> function above is defined as <code>impure</code></p>\n<h3 id=\"pure-function\"><a href=\"#pure-function\" class=\"headerlink\" title=\"pure function\"></a>pure function</h3><p>So we could come up with a better solution:</p>\n<figure class=\"highlight diff\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">// ['tag1', 'tag2', 'tag1  '] -&gt; ['tag1', 'tag2']</div><div class=\"line\">function clean(tags) &#123;</div><div class=\"line\">  let dedupe = &#123;&#125;;</div><div class=\"line\"><span class=\"addition\">+ let result = [];</span></div><div class=\"line\">  for (let i = 0; i &lt; tags.length; i++)&#123;</div><div class=\"line\"><span class=\"deletion\">-   tags[i] = tags[i].trim(); // mutates the tags</span></div><div class=\"line\"><span class=\"addition\">+   const aTag = tags[i].trim();</span></div><div class=\"line\"></div><div class=\"line\">    if(dedupe[aTag]) &#123;</div><div class=\"line\"><span class=\"deletion\">-     tags.splice(i, 1); // mutates the tags</span></div><div class=\"line\"><span class=\"deletion\">-     i--;</span></div><div class=\"line\"><span class=\"addition\">+     result.push(aTag);</span></div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">      dedupe[aTag] = true;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  return tags;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>with this implementation, at least we have get rid of the side effects and eliminated a potential caused by direct data mutation, but we could still do better:</p>\n<h3 id=\"Concatenated-loops\"><a href=\"#Concatenated-loops\" class=\"headerlink\" title=\"Concatenated loops\"></a>Concatenated loops</h3><img src=\"/2016/12/19/javascript-102/loop-patterns.png\" alt=\"Loop patterns\" title=\"Loop patterns\">\n<p>As illustrated in the image above, generally a good practice is try to wring <code>Concatenated loop</code>.</p>\n<p>To achieve this goal, we could follow a simple rule:</p>\n<blockquote>\n<p>Inside loop, try to do only 1 thing</p>\n</blockquote>\n<p>try to apply that to the <code>clean</code> function, we could get</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// ['tag1', 'tag2', 'tag1'] -&gt; ['tag1', 'tag2']</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">clean</span>(<span class=\"params\">tags</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">let</span> dedupe = &#123;&#125;;</div><div class=\"line\">  <span class=\"keyword\">let</span> result = [];</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; tags.length; i++) &#123;</div><div class=\"line\">    dedupe[tags[i].trim()] = <span class=\"literal\">true</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; tags.length; i++) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (dedupe[tags[i].trim()]) &#123;</div><div class=\"line\">      result.push(tags[i])</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">return</span> result;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Here inside those 2 loops, we could easily figure out what they are doing respectively.</p>\n<h3 id=\"Lazy-evaluation\"><a href=\"#Lazy-evaluation\" class=\"headerlink\" title=\"Lazy evaluation\"></a>Lazy evaluation</h3><p>However, some people may ask: this is a <code>O(2n)</code> compared to the previous <code>O(n)</code> function.</p>\n<p>Here will introduce the killer feature of <code>lodash</code> - chainable api</p>\n<p>it is basically implemented using <code>_.chain(collection)</code> method, or <code>_(collection)</code> as a shorthand, and could be optimized easily</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> result = _(source).map(func1).map(func2).map(func3).value();</div></pre></td></tr></table></figure>\n<p>is transformed to something like following in normal mode.</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> result = [], temp1 = [], temp2 = [], temp3 = [];</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; source.length; i++) &#123;</div><div class=\"line\"> temp1[i] = func1(source[i]);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; source.length; i++) &#123;</div><div class=\"line\"> temp2[i] = func2(temp1[i]);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; source.length; i++) &#123;</div><div class=\"line\"> temp3[i] = func3(temp2[i]);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">result = temp3;</div></pre></td></tr></table></figure>\n<p>But in the lazy mode (could be accomplished with <code>lazy.js</code>):</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> result = [];</div><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; source.length; i++) &#123;</div><div class=\"line\">  result[i] = func3(func2(func1(source[i])));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>as you could see, <code>O(kn)</code> algorithm has been optimized to <code>O(n)</code>. With pure <code>for</code> loop, this optimization is not easy to be achived, but with <code>lodash</code> and a sequence of function transformation, this could be easily achieved.</p>\n<h3 id=\"Lodash-Chainable-API-rewrite-clean-function\"><a href=\"#Lodash-Chainable-API-rewrite-clean-function\" class=\"headerlink\" title=\"Lodash Chainable API: rewrite clean function\"></a>Lodash Chainable API: rewrite <code>clean</code> function</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// ['tag1', 'tag2  ', 'tag1 '] -&gt; ['tag1', 'tag2']</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">clean</span>(<span class=\"params\">tags</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> _(tags)</div><div class=\"line\">    .map(_.trim)</div><div class=\"line\">    .uniq()</div><div class=\"line\">    .value();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>this is so much cleaner than the first version of above!</p>\n<p>read the documentation on <a href=\"https://lodash.com/docs/4.17.2#chain\">lodash chain</a> for more black magic</p>\n<h2 id=\"mergeAndOverwrite-function\"><a href=\"#mergeAndOverwrite-function\" class=\"headerlink\" title=\"mergeAndOverwrite function\"></a><code>mergeAndOverwrite</code> function</h2><p>consider the function below:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mergeAndOverwrite</span>(<span class=\"params\">target, source</span>) </span>&#123;</div><div class=\"line\">  target = _.merge(_.cloneDeep(target), source.merge);</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> config_key <span class=\"keyword\">in</span> source.overwrite) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (source.overwrite.hasOwnProperty(config_key)) &#123;</div><div class=\"line\">      target[config_key] = source.overwrite[config_key];</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">return</span> target;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>there are 2 gotchas:</p>\n<ol>\n<li>1st parameter in <code>_.merge</code> could be an empty object, and <code>_.merge</code> is a recursive deep operation already, so <code>_.cloneDeep</code> is somewhat a cumbersome call.</li>\n<li>the for … in loop could be entirely replaced by <code>Object.assign</code></li>\n</ol>\n<h3 id=\"merge-vs-Object-assign\"><a href=\"#merge-vs-Object-assign\" class=\"headerlink\" title=\"_.merge vs Object.assign\"></a>_.merge vs Object.assign</h3><p>Those 2 functions are similar but do things in totally different ways:</p>\n<ol>\n<li>.merge is a recursive call, so it traverses <strong>every</strong> property all object and merge them</li>\n<li>Object.assign only overwrite the 1st layer of right hand-side to left hands-side</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// =&gt; &#123; \"a\": &#123; \"a\": \"a\",\"b\":\"bb\" &#125;&#125;</span></div><div class=\"line\">_.merge(&#123;&#125;, &#123;<span class=\"attr\">a</span>:&#123;<span class=\"attr\">a</span>:<span class=\"string\">'a'</span>&#125;&#125;, &#123;<span class=\"attr\">a</span>:&#123;<span class=\"attr\">b</span>:<span class=\"string\">'bb'</span>&#125;&#125;)</div><div class=\"line\"><span class=\"comment\">// =&gt; &#123; \"a\": &#123; \"b\": \"bb\" &#125;&#125;</span></div><div class=\"line\"><span class=\"built_in\">Object</span>.assign(&#123;&#125;, &#123;<span class=\"attr\">a</span>:&#123;<span class=\"attr\">a</span>:<span class=\"string\">'a'</span>&#125;&#125;, &#123;<span class=\"attr\">a</span>:&#123;<span class=\"attr\">b</span>:<span class=\"string\">'bb'</span>&#125;&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// =&gt; &#123; \"a\": [ \"bb\" ] &#125;</span></div><div class=\"line\">_.merge(&#123;&#125;, &#123;<span class=\"attr\">a</span>:[<span class=\"string\">'a'</span>]&#125;, &#123;<span class=\"attr\">a</span>:[<span class=\"string\">'bb'</span>]&#125;)</div><div class=\"line\"><span class=\"comment\">// =&gt; &#123; \"a\": [ \"bb\" ] &#125;</span></div><div class=\"line\"><span class=\"built_in\">Object</span>.assign(&#123;&#125;, &#123;<span class=\"attr\">a</span>:[<span class=\"string\">'a'</span>]&#125;, &#123;<span class=\"attr\">a</span>:[<span class=\"string\">'bb'</span>]&#125;)</div></pre></td></tr></table></figure>\n<h3 id=\"rewrite-the-mergeAndOverwrite-function\"><a href=\"#rewrite-the-mergeAndOverwrite-function\" class=\"headerlink\" title=\"rewrite the mergeAndOverwrite function\"></a>rewrite the <code>mergeAndOverwrite</code> function</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mergeAndOverwrite</span>(<span class=\"params\">target, source</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">const</span> merged = _.merge(</div><div class=\"line\">    &#123;&#125;,</div><div class=\"line\">    target,</div><div class=\"line\">    source.merge</div><div class=\"line\">  );</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.assign(</div><div class=\"line\">    merged,</div><div class=\"line\">    source.overwrite</div><div class=\"line\">  );</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<div class=\"tip\"><br>Read through Lodash doc before using _.cloneDeep<br></div>\n\n<h2 id=\"Final-challenge-indentation-hell\"><a href=\"#Final-challenge-indentation-hell\" class=\"headerlink\" title=\"Final challenge: indentation hell\"></a>Final challenge: indentation hell</h2><p>To wrap up, consider the following function</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">filterAck</span>(<span class=\"params\">acl_hash</span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// 0</span></div><div class=\"line\">  <span class=\"keyword\">let</span> filtered_api_acl = &#123;&#125;;</div><div class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> api_version <span class=\"keyword\">in</span> acl_hash) &#123;</div><div class=\"line\">    <span class=\"comment\">// 1</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (acl_hash.hasOwnProperty(api_version)) &#123;</div><div class=\"line\">      <span class=\"comment\">// 2</span></div><div class=\"line\">      <span class=\"keyword\">if</span> (config.api_key.default_user_api_acl[api_version]) &#123;</div><div class=\"line\">        <span class=\"comment\">// 3</span></div><div class=\"line\">        filtered_api_acl[api_version] = [];</div><div class=\"line\">        <span class=\"keyword\">if</span> (_.isArray(acl_hash[api_version])) &#123;</div><div class=\"line\">          <span class=\"comment\">// 4</span></div><div class=\"line\">          <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; acl_hash[api_version].length; i++) &#123;</div><div class=\"line\">            <span class=\"comment\">// 5</span></div><div class=\"line\">            <span class=\"keyword\">if</span> (config.api_key.default_user_api_acl[api_version].indexOf(acl_hash[api_version][i]) !== <span class=\"number\">-1</span>) &#123;</div><div class=\"line\">              <span class=\"comment\">// 6</span></div><div class=\"line\">              filtered_api_acl[api_version].push(acl_hash[api_version][i]);</div><div class=\"line\">            &#125;</div><div class=\"line\">          &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> filtered_api_acl;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<div class=\"tip\"><br>We human beings are not good at reading deeply nested indentation hells: Research shows we only have 7 buffers for short term memory… So code like below will literally burn our brain out.<br></div>\n\n<img src=\"/2016/12/19/javascript-102/indentation-hell.jpg\" alt=\"indentation hell\" title=\"indentation hell\">\n<p>Whenever writing code, try your best to keep the indentation level &lt;= 3 is generally a good practice, <strong>this could vastly improve maintainability of code.</strong></p>\n<h3 id=\"1-use-Object-keys-to-iterate-an-object\"><a href=\"#1-use-Object-keys-to-iterate-an-object\" class=\"headerlink\" title=\"1. use Object.keys to iterate an object\"></a>1. use <code>Object.keys</code> to iterate an object</h3><p>indentation level <code>-1</code>, current <code>5</code></p>\n<figure class=\"highlight diff\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\">function filterAck(acl_hash) &#123;</div><div class=\"line\">  let filtered_api_acl = &#123;&#125;;</div><div class=\"line\"><span class=\"deletion\">- for (let api_version in acl_hash) &#123;</span></div><div class=\"line\"><span class=\"deletion\">-   if (acl_hash.hasOwnProperty(api_version)) &#123;</span></div><div class=\"line\"><span class=\"addition\">+ Object.keys(acl_hash).forEach(api_version =&gt; &#123;</span></div><div class=\"line\"><span class=\"deletion\">-     if (config.api_key.default_user_api_acl[api_version]) &#123;</span></div><div class=\"line\"><span class=\"addition\">+   if (config.api_key.default_user_api_acl[api_version]) &#123;</span></div><div class=\"line\"><span class=\"deletion\">-       filtered_api_acl[api_version] = [];</span></div><div class=\"line\"><span class=\"addition\">+     filtered_api_acl[api_version] = [];</span></div><div class=\"line\"><span class=\"deletion\">-       if (_.isArray(acl_hash[api_version])) &#123;</span></div><div class=\"line\"><span class=\"addition\">+     if (_.isArray(acl_hash[api_version])) &#123;</span></div><div class=\"line\"><span class=\"deletion\">-         for (let i = 0; i &lt; acl_hash[api_version].length; i++) &#123;</span></div><div class=\"line\"><span class=\"addition\">+       for (let i = 0; i &lt; acl_hash[api_version].length; i++) &#123;</span></div><div class=\"line\"><span class=\"deletion\">-           if (config.api_key.default_user_api_acl[api_version].indexOf(acl_hash[api_version][i]) !== -1) &#123;</span></div><div class=\"line\"><span class=\"addition\">+         if (config.api_key.default_user_api_acl[api_version].indexOf(acl_hash[api_version][i]) !== -1) &#123;</span></div><div class=\"line\"><span class=\"deletion\">-             filtered_api_acl[api_version].push(acl_hash[api_version][i]);</span></div><div class=\"line\">            // 5</div><div class=\"line\"><span class=\"addition\">+           filtered_api_acl[api_version].push(acl_hash[api_version][i]);</span></div><div class=\"line\"><span class=\"deletion\">-           &#125;</span></div><div class=\"line\"><span class=\"addition\">+         &#125;</span></div><div class=\"line\"><span class=\"deletion\">-         &#125;</span></div><div class=\"line\"><span class=\"addition\">+       &#125;</span></div><div class=\"line\"><span class=\"deletion\">-       &#125;</span></div><div class=\"line\"><span class=\"addition\">+     &#125;</span></div><div class=\"line\"><span class=\"deletion\">-     &#125;</span></div><div class=\"line\"><span class=\"addition\">+   &#125;</span></div><div class=\"line\"><span class=\"deletion\">- &#125;</span></div><div class=\"line\"><span class=\"addition\">+ &#125;);</span></div><div class=\"line\">  return filtered_api_acl;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"2-use-intersction-to-simplify-replace-the-inner-loop\"><a href=\"#2-use-intersction-to-simplify-replace-the-inner-loop\" class=\"headerlink\" title=\"2. use _.intersction to simplify replace the inner loop\"></a>2. use <code>_.intersction</code> to simplify replace the inner loop</h3><p>indentation level <code>-2</code>, current: <code>3</code></p>\n<figure class=\"highlight diff\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">function filterAcl(acl_hash) &#123;</div><div class=\"line\">  let filtered_api_acl = &#123;&#125;;</div><div class=\"line\">  Object.keys(acl_hash).forEach(api_version =&gt; &#123;</div><div class=\"line\">    if (config.api_key.default_user_api_acl[api_version]) &#123;</div><div class=\"line\"><span class=\"addition\">+     filtered_api_acl[api_version] = [];</span></div><div class=\"line\">      if (_.isArray(acl_hash[api_version])) &#123;</div><div class=\"line\"><span class=\"deletion\">-       for (let i = 0; i &lt; acl_hash[api_version].length; i++) &#123;</span></div><div class=\"line\"><span class=\"deletion\">-         if (config.api_key.default_user_api_acl[api_version].indexOf(acl_hash[api_version][i]) !== -1) &#123;</span></div><div class=\"line\"><span class=\"deletion\">-           filtered_api_acl[api_version].push(acl_hash[api_version][i]);</span></div><div class=\"line\"><span class=\"deletion\">-         &#125;</span></div><div class=\"line\"><span class=\"deletion\">-       &#125;</span></div><div class=\"line\">        // 3</div><div class=\"line\"><span class=\"addition\">+       filtered_api_acl[api_version] = _.intersction(</span></div><div class=\"line\"><span class=\"addition\">+         config.api_key.default_user_api_acl[api_version],</span></div><div class=\"line\"><span class=\"addition\">+         acl_hash</span></div><div class=\"line\"><span class=\"addition\">+       )</span></div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;)</div><div class=\"line\">  return filtered_api_acl;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"3-return-in-advance-to-reduce-indentation-level\"><a href=\"#3-return-in-advance-to-reduce-indentation-level\" class=\"headerlink\" title=\"3. return in advance to reduce indentation level\"></a>3. return in advance to reduce indentation level</h3><p>indentation level <code>-1</code>, current <code>2</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">filterAcl</span>(<span class=\"params\">acl_hash</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">let</span> filtered_api_acl = &#123;&#125;;</div><div class=\"line\">  <span class=\"built_in\">Object</span>.keys(acl_hash).forEach(<span class=\"function\"><span class=\"params\">api_version</span> =&gt;</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (!config.api_key.default_user_api_acl[api_version]) &#123;</div><div class=\"line\">      <span class=\"comment\">// 2</span></div><div class=\"line\">      <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (!_.isArray(acl_hash[api_version])) &#123;</div><div class=\"line\">      <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    filtered_api_acl[api_version] = [];</div><div class=\"line\"></div><div class=\"line\">    filtered_api_acl[api_version] = _.intersection(</div><div class=\"line\">      config.api_key.default_user_api_acl[api_version],</div><div class=\"line\">      acl_hash[api_version]</div><div class=\"line\">    );</div><div class=\"line\">  &#125;);</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">return</span> filtered_api_acl;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"4-final-step-use-lodash-to-wrap-everything\"><a href=\"#4-final-step-use-lodash-to-wrap-everything\" class=\"headerlink\" title=\"4. final step: use lodash to wrap everything\"></a>4. final step: use lodash to wrap everything</h3><p>indentation level <code>-2</code>, current <code>0</code></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">filterAcl</span>(<span class=\"params\">acl_hash</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> _</div><div class=\"line\">    .chain(<span class=\"built_in\">Object</span>.keys(acl_hash))</div><div class=\"line\">    .filter(<span class=\"function\"><span class=\"params\">api_version</span> =&gt;</span> config.api_key.default_user_api_acl[api_version])</div><div class=\"line\">    .filter(<span class=\"function\"><span class=\"params\">api_version</span> =&gt;</span> <span class=\"built_in\">Array</span>.isArray(acl_hash[api_version]))</div><div class=\"line\">    .map(<span class=\"function\"><span class=\"params\">api_version</span> =&gt;</span> ([</div><div class=\"line\">      api_version,</div><div class=\"line\">      _.intersection(</div><div class=\"line\">        config.api_key.default_user_api_acl,</div><div class=\"line\">        acl_hash[api_version]</div><div class=\"line\">      )</div><div class=\"line\">    ]))</div><div class=\"line\">    .fromPairs()</div><div class=\"line\">    .value();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"Final-Words\"><a href=\"#Final-Words\" class=\"headerlink\" title=\"Final Words\"></a>Final Words</h2><div class=\"tip\"><br>Use Lodash!<br></div>\n\n<h4 id=\"references\"><a href=\"#references\" class=\"headerlink\" title=\"references:\"></a>references:</h4><ul>\n<li><a href=\"https://lodash.com/docs/4.17.2\">lodash-doc</a></li>\n<li><a href=\"http://philosopherdeveloper.com/posts/introducing-lazy-js.html\">lazy-js-intro</a></li>\n<li><a href=\"http://stackoverflow.com/questions/500504/why-is-using-for-in-with-array-iteration-a-bad-idea\">for-in-stackoverflow</a></li>\n<li><a href=\"https://laracasts.com/series/simple-rules-for-simpler-code\">simple-rules-for-simple-code</a></li>\n</ul>"}],"PostAsset":[{"_id":"source/_posts/javascript-102/loop-patterns.png","slug":"loop-patterns.png","post":"ciwwar0jl0000gqgf2ijk87ga","modified":0,"renderable":0},{"_id":"source/_posts/javascript-102/indentation-hell.jpg","slug":"indentation-hell.jpg","post":"ciwwar0jl0000gqgf2ijk87ga","modified":0,"renderable":0}],"PostCategory":[{"post_id":"ciwwar0jl0000gqgf2ijk87ga","category_id":"ciwwar0lu0001gqgf214kbo9o","_id":"ciwwar0m30004gqgfmmav3q1x"}],"PostTag":[{"post_id":"ciwwar0jl0000gqgf2ijk87ga","tag_id":"ciwwar0m10002gqgfdk9hf6ol","_id":"ciwwar0m40006gqgfdde0ru0c"},{"post_id":"ciwwar0jl0000gqgf2ijk87ga","tag_id":"ciwwar0m20003gqgfkvkv9zn5","_id":"ciwwar0m40007gqgf0lppbbdt"},{"post_id":"ciwwar0jl0000gqgf2ijk87ga","tag_id":"ciwwar0m30005gqgfnn2d41cm","_id":"ciwwar0m50008gqgfe3esfcm2"}],"Tag":[{"name":"JavaScript","_id":"ciwwar0m10002gqgfdk9hf6ol"},{"name":"Lodash","_id":"ciwwar0m20003gqgfkvkv9zn5"},{"name":"Code Quality","_id":"ciwwar0m30005gqgfnn2d41cm"}]}}